{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction to Geospatial Data Processing in R","text":"<p>Materials for the course KFG/7ZGER - Introduction to Geospatial Data Processing in R taught at the Department of Physical Geography and Geoecology of the University of Ostrava. The course is intended for students of envionmental geography.</p> <p>Warning</p> <p>The materials are inconsistent and incomplete. They primarily serve to summarize individual exercises to facilitate orientation in the course during self-study. For detailed information, it is necessary to attend the exercises or seek information in the recommended sources.</p>"},{"location":"#moodle","title":"Moodle","text":"<p>The current year's course is conducted on Moodle, where information for individual exercises and especially assignments can be found:</p> <p>KFG/7ZGER - Spring semester 25/26</p>"},{"location":"#other-courses","title":"Other courses","text":""},{"location":"basics/","title":"R Basics","text":""},{"location":"basics/#r-as-a-calculator","title":"R as a calculator","text":"<p>First steps we can do is to use R as a calculator. Type the code directly in the Console pane where <code>&gt;</code> is shown, and press <code>Enter</code> to run (execute) it. The <code>&gt;</code> sign, is promt, that R is ready to accept commands. </p> <pre><code>1 + 1\n</code></pre> <p>The result will be printed below the command:</p> <pre><code>[1] 2\n</code></pre> <p>The <code>[1]</code> is just console line label, which is useful when printing objects containing more values, which will be explained later.</p> <p>So you should see this in your console:</p> <pre><code>&gt; 1 + 1\n[1] 2\n</code></pre> <p>Use <code>**</code> or <code>^</code> for exponentiation</p> <pre><code>5 * 5 / (3 + 10)\n5**2 / (3 + 10)\n</code></pre>"},{"location":"basics/#relational-operators","title":"Relational operators","text":"<p>You can also compare values to test whether they meet a condition. This returns a logical value, <code>TRUE</code> or <code>FALSE</code>.</p> <ul> <li><code>==</code> - equals</li> <li><code>!=</code> - not equals</li> <li><code>&gt;</code> - greater than</li> <li><code>&lt;</code> - less than</li> <li><code>&gt;=</code> - greater or equal</li> <li><code>&lt;=</code> - less or equal</li> </ul> <pre><code>5 == 5\n</code></pre> <pre><code>[1] TRUE\n</code></pre> <p>try: <pre><code>5 &gt; 10\n6 != 6\n10 &lt;= 10\n8 &gt; 2 * 3\n</code></pre></p>"},{"location":"basics/#variables","title":"Variables","text":"<p>Values and other objects can be assigned to variables with operator <code>&lt;-</code>. Executing the variable name is call printing and will print the value assigned in it. Imagine variables as links to the stored values.</p> <pre><code>x &lt;- 42\n\nx\n</code></pre> <pre><code>[1] 42\n</code></pre> <pre><code>x &lt;- 7\ny &lt;- 6\n\ny * x\n</code></pre> <p>Assigning a value to existing variable will overwrite the previous value.</p> <pre><code>x &lt;- 7\ny &lt;- 6\nx &lt;- 2\n\ny * x\n</code></pre> <p>The result of any operation can be assigned to a variable:</p> <pre><code>x &lt;- 5\ny &lt;- 10\nz &lt;- x + y\nz\n</code></pre> <p>Variables names:</p> <ul> <li>can't contain spaces and special characters</li> <li>can't start with number</li> <li>are case sensitive</li> <li>can't be some reserved words (<code>if</code>, <code>for</code>, ...)</li> </ul> <pre><code>variable1 &lt;- 5\nvariable1\n</code></pre> <p><pre><code>1variable &lt;- 5\n1variable\n</code></pre> The convention is to use descriptive but not excessive long variable names. There are tree main types of naming in R:</p> <ul> <li>snake_case - used in this course</li> <li>camelCase</li> <li>dot.case - not recommended</li> </ul> <p>Use what you like, but be consistent.</p> <pre><code>my_variable &lt;- 5\nmy_variable\n</code></pre>"},{"location":"basics/#text-values","title":"Text values","text":"<p>We will also work with text values, which are written in quotes, either single <code>'text'</code> or double <code>\"text\"</code>.</p> <pre><code>my_text &lt;- \"Hello World\"\nmy_text\n</code></pre> <p><pre><code>[1] \"Hello World\"\n</code></pre> Text values can be also compared with relational operators and they will be compared alphabetically:</p> <pre><code>a &lt;- \"A\"\nb &lt;- \"B\"\na == b\na &lt; b\na == \"a\"\n</code></pre>"},{"location":"basics/#functions","title":"Functions","text":"<p>Calling function consist of function name and usually arguments in parentheses. Arguments can be named or unnamed.  <code>function_name(argument1 = value1 ,argument2 = value2, argument3 = value3, ...)</code>.  There are also functions that doesn't have any arguments (<code>getwd()</code>).</p> <p>Try functions <code>round()</code> and <code>abs()</code>: <pre><code>round(3.14159)\n</code></pre></p> <p>You can get function help using RStudio GUI or calling <code>?</code> before the function name, or <code>help()</code> function. Help gives you information about the function, its arguments and their default values, and usage examples.</p> <pre><code>?round\n</code></pre> <p>In help we found the argument <code>digits</code>, try it: <pre><code>round(3.14159, digits = 2)\n</code></pre></p> <p>or just <pre><code>round(3.14159, 2)\n</code></pre></p> <p>Note</p> <p>Actually the function runs <pre><code>round(x = 3.14159, digits = 2)\n</code></pre> where <code>x</code> is the first unnamed argument.</p> <p>Another simple function is <code>abs()</code> - absolute value:</p> <pre><code>abs(-16)\n</code></pre>"},{"location":"basics/#writing-scripts","title":"Writing scripts","text":"<p>As mentioned in the Introduction to R there are various ways to write and run code in R, interacively in the console, or writing scripts that can be saved and run later (entire or by parts). Most of the time you will write code to scripts (<code>.R</code> or <code>.r</code> files). Code can be written in any text editor.</p>"},{"location":"basics/#runing-code","title":"Runing code","text":"<p>In RStudio you can write and save scripts in the Source pane. You can run the entire script or just the selected part of the code. </p> <ul> <li>Run selected part of the code - <code>Ctrl + Enter</code> - or button <code>Run</code> - this you willl use mostly in this course. You can run the code line by line, or by selected blocks. This function sends the code to the console and run it, and the cursor will move to the next line or executable part of code.</li> </ul>"},{"location":"basics/#comments","title":"Comments","text":"<p>In writing scripts you can \"comment\" lines. Commented lines starts with <code>#</code> and are not executed (even if they are sent to the console). Coments are useful for documenting/explanation code or \"deactivating\" parts of code.</p> <pre><code># Do some math\nx &lt;- 5\ny &lt;- 8\n# y &lt;- 10\ny\nx + y\n</code></pre>"},{"location":"basics/#summary","title":"Summary","text":""},{"location":"basics/#main-outcomes","title":"Main outcomes","text":"<ul> <li>use R as calculator and understand basic value comparisons interactively in console</li> <li>what is variable and how to assign values to it with <code>&lt;-</code></li> <li>how to use functions and get help for them</li> <li>how to write and run code from scripts (source pane in RStudio)</li> </ul>"},{"location":"basics/#function-overview","title":"Function overview","text":"<ul> <li><code>round()</code> - round a number to a specified number of decimal places</li> <li><code>abs()</code> - absolute value of a number</li> </ul>"},{"location":"data/","title":"Data","text":""},{"location":"data_combination/","title":"Data combination","text":"<p>Warning</p> <p>This page is in state from the spring semester 25, and will undergo changes for the actual semester.</p>"},{"location":"data_combination/#general-r-functions","title":"General R functions","text":""},{"location":"data_combination/#basic-string-manipulation","title":"Basic string manipulation","text":"<p>The most common string manipulation functions in R are <code>paste</code>, <code>paste0</code>, <code>gsub</code>, and <code>substr</code>. These are useful for data cleaning and preparation, and working with paths, filenames, URLs etc.</p>"},{"location":"data_combination/#paste-and-paste0","title":"<code>paste</code> and <code>paste0</code>","text":"<p><code>paste</code> and <code>paste0</code> are used to concatenate strings. They are similar, <code>paste0</code> is a shortcut for <code>paste</code> without <code>sep</code> argument, while <code>paste</code> has default <code>sep = \" \"</code>. </p> <pre><code>paste(\"Hello\", \"World\")\npaste(\"Hello\", \"World\", sep = \" - \")\nx &lt;- paste0(\"Hello\", \"World\")\n</code></pre>"},{"location":"data_combination/#gsub","title":"<code>gsub</code>","text":"<p><code>gsub</code> is used to replace all occurrences of a pattern in a string. It uses regular expressions.</p> <pre><code>x &lt;- \"Hello World\"\ngsub(\"World\", \"R\", x)\n</code></pre>"},{"location":"data_combination/#substr","title":"<code>substr</code>","text":"<p><code>substr</code> is used to extract a substring from a string</p> <pre><code>x &lt;- paste0(\"Hello\", \"World\")\nsubstr(x, 6, 10)\n</code></pre> <p><pre><code>my_date &lt;- \"20250409\"\nyear &lt;- substr(date, 1, 4)\nmonth &lt;- substr(date, 5, 6)\nday &lt;- substr(date, 7, 8)\n</code></pre> <code>substr</code> can be also used to replace a sring <pre><code>my_date &lt;- \"20250409\"\nsubstr(my_date, 1, 4) &lt;- \"2023\"\n\nmy_date\n</code></pre></p> <p>Note</p> <p>Notice that good practices to work with dates is use dedicated functions. In base R you can use <code>as.Date()</code> or <code>as.POSIXct()</code>. </p> <pre><code>my_date &lt;- \"20250409\"\ndate_obj &lt;- as.Date(my_date, format = \"%Y%m%d\")\n\nyear &lt;- format(date_obj, \"%Y\")\n\nprint(date_obj)\nprint(year)\n</code></pre>"},{"location":"data_combination/#basic-automatisation","title":"Basic automatisation","text":""},{"location":"data_combination/#docall","title":"<code>do.call</code>","text":"<p>Todo</p>"},{"location":"data_combination/#apply-family-of-functions","title":"<code>apply</code> family of functions","text":"<p>The <code>apply</code> family of functions is used to apply a function to each element of an object (like a list or a matrix). The most common functions are <code>apply</code> for arrays, matrices and data frames, and <code>lapply</code> for lists (or simplified <code>lapply</code> - <code>sapply</code>, which returns vector).</p> <pre><code>x &lt;- list(1:10, 11:20, 21:30)\nsum(x)\nlapply(x, sum)\n</code></pre> <p>when using <code>apply</code> function, you need to specify the <code>MARGIN</code> argument, which defines if you want to apply the function to rows or columns. <code>MARGIN = 1</code> for rows, <code>MARGIN = 2</code> for columns.</p> <pre><code>df &lt;- data.frame(a = 1:5, b = 6:10)\ndf\napply(df, 1, sum) \napply(df, 2, sum) \n</code></pre>"},{"location":"data_combination/#for-loops","title":"<code>for</code> loops","text":"<p>Basic <code>for</code> loops are used to iterate over a sequence of numbers or elements. The code use executed repeatedly for each element in the sequence. If you want to see what is happening on certain place in the loop, you can use <code>print()</code> function, which behaves similarly to runinng variable in the console.  </p> <p>Note</p> <p>In many cases, you can use <code>lapply</code> or <code>sapply</code> instead of <code>for</code> loops. They can be more efficient and sometimes easier to read. </p> <pre><code>for (i in 1:10) {\n    print(i)\n}\n</code></pre> <pre><code>for (i in 1:10) {\n    paste(\"Hello\", \"I can't see this\")\n    what_is_happening &lt;- paste(\"This is iteration number\", i)\n    print(what_is_happening)\n}\n</code></pre> <p>Lot of times you will need to store the results of the loop in a vector or list. Good practice is to preallocate the vector or list before the loop. </p> <pre><code>vector_of_results &lt;- c()\nfor (i in 1:10) {\n    vector_of_results[i] &lt;- paste(\"This is iteration number\", i)\n}\n</code></pre> <pre><code>list_of_results &lt;- list()\nfor (i in 1:10) {\n    list_of_results[[i]] &lt;- paste(\"This is iteration number\", i)\n}\n</code></pre> <p>Note</p> <p>If you know number of elements in desired list, than more efficient way to preallocate the vector is to use <code>vector()</code> function. This avoids the resizing the list in each iteration, which can be slower in large loops.</p> <pre><code>list_of_results &lt;- vector(\"list\", length = 10)\nfor (i in 1:10) {\n    list_of_results[[i]] &lt;- paste(\"This is iteration number\", i)\n}\n</code></pre> <p>Warning</p> <p>Try to avoid appending/combining a resulted vector or list in each iteration of the loop. Its works fine for small loops, but can be slow and inefficient for large loops, due to creating a new vector in each iteration in memory.</p> <pre><code>#bad practise:\nvector_of_results &lt;- c()\nfor (i in 1:10) {\n    vector_of_results &lt;- c(vector_of_results, paste(\"This is iteration number\", i))\n}\n</code></pre> <p>Tip</p> <p>Get the good practices, but do not be afraid to use the code that works for you. Be aware of possible performance improvements when your code goes slow.</p>"},{"location":"data_combination/#downloading-data-from-a-list-of-urls","title":"Downloading data from a list of urls","text":"<p>Example of downloading files from a list of urls. We will download data from LPIS (https://mze.gov.cz/public/app/eagriapp/lpisdata/) and save them to the local <code>data</code> directory. </p> <p>URL for the zip files are structured as follows: https://mze.gov.cz/public/app/eagriapp/lpisdata/20250405-713830-DPB-SHP.zip</p> <p>Where <code>20250405</code> is the date of the data, <code>713830</code> is the code of the municipality, and <code>DPB-XML-A</code> is the type of data. </p> <p>So we can use <code>paste0</code> to create the url for each municipality and date. </p> <pre><code>municip_codes &lt;- c(682675, 683434, 683442, 683451)\nroot_url &lt;- \"https://mze.gov.cz/public/app/eagriapp/lpisdata/20250405-\"\n\nfor (municip_code in municip_codes) {\n    url &lt;- paste0(root_url, municip_code, \"-DPB-SHP.zip\")\n    destfile &lt;- paste0(\"data/\", municip_code, \"-DPB-SHP.zip\")\n    download.file(url, destfile)\n}\n</code></pre> <p>You can enchance the code by unzipping the files after downloading and deleting the zip files. </p> <pre><code>for (municip_code in municip_codes) {\n    url &lt;- paste0(root_url, municip_code, \"-DPB-SHP.zip\")\n    destfile &lt;- paste0(\"data/\", municip_code, \"-DPB-SHP.zip\")\n    download.file(url, destfile)\n\n    # Unzip the file\n    unzip(destfile, exdir = \"data/\")\n\n    # Delete the zip file\n    file.remove(destfile)\n}\n</code></pre>"},{"location":"data_combination/#spatial-data-combination","title":"Spatial data combination","text":"<p>Read the data from the local directory. Note that we will use <code>terra</code> package also for reading the shapefiles. </p> <pre><code>library(terra)\n\n#raster\nr &lt;- rast(\"data/eudem.tif\")\nnames(r) &lt;- \"elev\"\n\n#vector\nshp_paths &lt;- list.files(\"data\", pattern = \".shp$\", full.names = TRUE)\nlpis &lt;- vect(shp_paths[1])\n</code></pre>"},{"location":"data_combination/#crop-raster-data-with-vector-data","title":"crop raster data with vector data","text":"<p>Same as in previous example, we can crop the raster data with the vector data, as the function takes the extent object from the raster or vector data. </p> <pre><code>r_cropped &lt;- crop(r, lpis)\nplot(r_cropped)\nplot(lpis, add = TRUE)\n</code></pre>"},{"location":"data_combination/#zonal-statistics","title":"zonal statistics","text":"<p>For zonal statistics, we can use <code>zonal()</code> function, with <code>fun</code> argument to specify the statistics we want to calculate. Default is <code>mean</code>, see <code>?zonal</code> for more options. </p> <pre><code>zonal_r &lt;- zonal(r, lpis)\nzonal_r\n</code></pre> <p>If you need the original polygon object with appended statistics, you can use <code>as.polygon = TRUE</code> argument. </p> <p><pre><code>zonal_r &lt;- zonal(r, lpis, as.polygon = TRUE)\nzonal_r\nzonal_r$elev\nplot(zonal_r)\n</code></pre> task: whats the difference between original elevation in <code>VYSKA</code> and recalculated elevation in <code>elev</code>? </p> <pre><code>zonal_r$elev - zonal_r$VYSKA\n</code></pre>"},{"location":"data_combination/#raster-value-extraction","title":"raster value extraction","text":"<p>To extract raster values at specific features or raster pixels, we can use <code>extract()</code> function. It can be used with any vector object, not only points. In case of polygons its similar to zonal statistics. See <code>?extract</code> for more options. </p> <p>Get raster vales for lpis centroids</p> <pre><code>lpis_pts &lt;- centroids(lpis)\nextract(r, lpis_pts)\n#or\nelev_pts &lt;- extract(r, lpis_points, bind = TRUE)\nplot(r_cropped)\nplot(lpis, add = TRUE)\nplot(elev_pts, add = TRUE, col = \"red\")\n</code></pre>"},{"location":"data_combination/#bodnus","title":"bodnus","text":"<pre><code>plot(r_cropped)\nfor (i in seq(elev_pts)) {\n    plot(lpis[i], add = TRUE)\n    plot(elev_pts[i], add = TRUE, col = \"red\")\n    Sys.sleep(0.2)\n}\n</code></pre>"},{"location":"data_types/","title":"Data structures","text":""},{"location":"data_types/#data-types","title":"Data types","text":"<p>As we saw in previous section, in R, as in every other software for working with data, we operate with various types of data (e.g., numbers, text, logical values). These types of data are in R called data types and they are important to understand, so we can work with the data properly and know what functions we can use. </p> <p>Basic data types in R, that we will use in this course are:</p> <ul> <li>double - real numbers - <code>1.23</code></li> <li>integer - whole numbers - <code>1L</code></li> <li>character - text - <code>\"Hello, world!\"</code> </li> <li>logical - TRUE or FALSE - <code>TRUE</code></li> <li>list - a collection of any objects, including other lists and objects we will learn later in course - <code>list(1, \"a\", TRUE)</code></li> </ul> <p>Check the data type of the object with <code>typeof()</code> function. This returns the low level datatype of the object sotred in memory. </p> <pre><code>num &lt;- 5.1\ntypeof(num)\n</code></pre> <pre><code>[1] \"double\"\n</code></pre> <pre><code>num &lt;- 5\ntypeof(num)\n</code></pre> <p><pre><code>[1] \"double\"\n</code></pre> This seems to be unexpected, but even if we write whole number, R stores it as double by default. If you want to store it as integer, you have to add <code>L</code> at the end of the number, or use conversion functions that explained later.</p> <pre><code>num_int &lt;- 5L\ntypeof(num_int)\n</code></pre> <pre><code>[1] \"integer\"\n</code></pre> <pre><code>some_text &lt;- \"Hello, world!\"\ntypeof(some_text)\n</code></pre> <pre><code>[1] \"character\"\n</code></pre> <pre><code>x &lt;- \"5\"\ntypeof(x)\n</code></pre> <pre><code>[1] \"character\"\n</code></pre> <pre><code>x &lt;- TRUE\ntypeof(x)\n</code></pre> <pre><code>[1] \"logical\"\n</code></pre> <p>Technical note</p> <p><code>TRUE</code> and <code>FALSE</code> are reserved words in R, but you can also use <code>T</code> and <code>F</code> as shortcuts for them. Hovewer <code>TRUE</code> and <code>FALSE</code> are more explicit, readable, and less error prone, because <code>T</code> and <code>F</code> are just predefined variables and can be redefined by user.</p> <pre><code>TRUE &lt;- 456 \n</code></pre> <pre><code>TRUE == T\nT &lt;- 456\nTRUE == T\nT &lt;- TRUE\nTRUE == T\n</code></pre> <pre><code>x &lt;- 5 == 5\ntypeof(x)\n</code></pre> <p><pre><code>[1] \"logical\"\n</code></pre> Basic awareness of data types is also important to understand more complex data structures later. Also it is needed for basic data manipulation, for instance when correcting data that have been read incorrectly from tables. For example when numbers are read as characters and vice versa. </p>"},{"location":"data_types/#data-type-conversion","title":"Data type conversion","text":"<p>Conversion between types can be done with functions <code>as.*</code> family.</p> <p>text (character) to numeric:</p> <p><pre><code>\"5\" + 5\nx &lt;- as.double(\"5\")\nx + 5\n</code></pre> or</p> <pre><code>as.numeric(\"5\")\n</code></pre> <p>numeric to text (character):</p> <pre><code>as.character(123)\n</code></pre>"},{"location":"data_types/#vectors-atomic-vectors","title":"Vectors (Atomic vectors)","text":"<p>Atomic vectors are fundamental data structure in R. It is sequence of elements of same data type (homogenous). Even a single value, like <code>5</code>, <code>\"a\"</code>, or <code>TRUE</code>, is technically an atomic vector of length 1. Atomic vectors of multiple values can be created with <code>c()</code> function (combine), and are usually called simply vectors.</p> <pre><code>c(1, 15, 4, 6)\n</code></pre> <p><pre><code>[1]  1 15  4  6\n</code></pre> <pre><code>typeof(c(1, 15, 4, 6))\n</code></pre></p> <pre><code>[1] \"double\"\n</code></pre> <p>Numeric sequence can be created various ways, basic approach is use <code>:</code> operator</p> <pre><code>1:10\n</code></pre> <pre><code>[1]  1  2  3  4  5  6  7  8  9 10\n</code></pre> <p>Technical note</p> <p><code>:</code> operator creates sequence of integers if both numbers are integers</p> <p>Tip</p> <p>You can make a specific sequence of numbers with <code>seq()</code> function and arguments <code>from</code>, <code>to</code>, <code>by</code>: <pre><code>seq(1, 10, by = 2)\n</code></pre></p> <pre><code>[1] 1 3 5 7 9\n</code></pre> <p>vector of characters:</p> <pre><code>c(\"a\", \"b\", \"c\")\n</code></pre> <pre><code>[1] \"a\" \"b\" \"c\"\n</code></pre> <p>vector of logical values:</p> <pre><code>c(TRUE, FALSE, TRUE)\n</code></pre> <pre><code>[1]  TRUE FALSE  TRUE\n</code></pre> <p>As (atomic) vectors can't contain values of different types, various types will be converted, see <code>?c</code>.</p> <pre><code>c(\"123\", 456, TRUE)\n</code></pre> <pre><code>[1] \"123\"  \"456\"  \"TRUE\"\n</code></pre> <p>Technical note</p> <p>When we combine different types of data, R will convert them to the most general type. </p> <p>The <code>==</code> help <code>?\"==\"</code> says: <pre><code>If the two arguments are atomic vectors of different types, one is\ncoerced to the type of the other, the (decreasing) order of\nprecedence being character, complex, numeric, integer, logical and\nraw.\n</code></pre> The <code>c()</code> help <code>?c</code> says: <pre><code>The output type is determined from the highest type of the\ncomponents in the hierarchy NULL &lt; raw &lt; logical &lt; integer &lt;\ndouble &lt; complex &lt; character &lt; list &lt; expression.\n</code></pre></p> <p>And the arithemetic operations help <code>?Arithmetic</code> or <code>?\"+\"</code> says: <pre><code>Logical vectors will be coerced to integer or numeric vectors,\n\u2018FALSE\u2019 having value zero and \u2018TRUE\u2019 having value one.\n</code></pre></p> <p>For our purposes the logical &lt; integer &lt; double priority and that TRUE and FALSE are considered as 1 and 0 respectively is the most important.</p> <p>Thats why <code>c(\"123\", 456, TRUE)</code> returns character vector, because character is the most general type</p> <p>Try another examples: <pre><code>\"123\" == 123\nTRUE + 5\nTRUE == \"TRUE\"\nTRUE == \"T\"\n</code></pre></p> <p>You can do operations with vectors of the same length.</p> <pre><code>x &lt;- c(1, 2, 3, 4)\ny &lt;- c(5, 6, 7, 8)\n\nx + y\n</code></pre> <pre><code>[1]  6  8 10 12\n</code></pre> <p>But also its multiple. The simplest example is adding a single number to vector:</p> <pre><code>x &lt;- c(1, 2, 3, 4)\nx + 10\n</code></pre> <p><pre><code>[1] 11 12 13 14\n</code></pre> This is called recycling and it works with vectors of different lengths, but the shorter vector has to be multiple of the longer one. </p> <p>When you execute: <pre><code>x &lt;- c(1, 2, 3, 4)\nx + 10\n</code></pre> R is actually using <code>c(10, 10, 10, 10)</code> as the second vector, because it recycles the value <code>10</code> to match the length of <code>x</code>.</p> <p>Another example: <pre><code>x &lt;- c(1, 2, 3, 4)\ny &lt;- c(10, 20)\nx+y\n</code></pre> Here, R is using <code>c(10, 20, 10, 20)</code> as <code>y</code>, and so on.</p> <p>This works also with comparison operators:</p> <pre><code>x &lt;- (\"a\", \"b\", \"c\",\"c\")\nx == \"c\"\n</code></pre> <p><pre><code>[1] FALSE FALSE  TRUE  TRUE\n</code></pre> In this case <code>\"c\"</code> is recycled to <code>c(\"c\", \"c\", \"c\", \"c\")</code> and compared to each element of <code>x</code>.</p> <p>Adding element to existing vector:</p> <pre><code>x &lt;- c(\"a\", \"b\", \"c\")\nx\n\nx &lt;- c(x, \"d\")\nx\n</code></pre> <p>Function <code>length()</code> returns the length of the vector - number of elements in the vector.</p> <pre><code>x &lt;- c(1, 2, 3, 4)\nlength(x)\n</code></pre> <pre><code>[1] 4\n</code></pre> <p>You can use basic descriptive statistics functions as <code>sum()</code>, <code>mean()</code>, <code>min()</code>, <code>max()</code> etc. <pre><code>x &lt;- c(1, 2, 3, 4, 5, 8, 13, 51)\nsum(x)\n</code></pre></p> <pre><code>[1] 97\n</code></pre> <p>try: <pre><code>mean(x)\nmin(x)\nmax(x)\n</code></pre></p> <p>Example</p> Examples12 <p>When you get used to with the basics we learned to this point, you can already do some basic data manipulation and analysis. </p> <ol> <li>How many values in vector <code>x</code> are greater than 5?</li> <li>How many times the \"species A\" is in vector <code>species</code>?</li> </ol> <p>This can be done with combination of what we learned, however we will learn more efficient ways to do this later in course.</p> <pre><code>x &lt;- c(1, 2, 3, 4,5, 8, 13, 51)\nspecies &lt;- c(\"species A\", \"species B\", \"species C\", \"species A\", \"species B\", \"species A\")\n</code></pre> <p>How many values in vector <code>x</code> are greater than 5?</p> <p><pre><code>x &lt;- c(1, 2, 3, 4,5, 8, 13, 51)\ntf &lt;- x &gt; 5\nsum(tf)\n</code></pre> or simply: <pre><code>sum(x &gt; 5)\n</code></pre></p> <p>How many times the \"species A\" is in vector <code>species</code>?</p> <p><pre><code>species &lt;- c(\"species A\", \"species B\", \"species C\", \"species A\", \"species B\", \"species A\")\ntf &lt;- species == \"species A\"\nsum(tf)\n</code></pre> or simply: <pre><code>sum(species == \"species A\")\n</code></pre></p>"},{"location":"data_types/#basics-of-indexing-vectors","title":"Basics of indexing vectors","text":"<p>Indexing is a basic operation used to extract parts of data. We will use indexing extensively throughout this course.</p> <p>Vectors are not only collections of elements but also ordered structures. This ordering allows us to extract elements by their position using numeric indices or logical vectors inside square brackets <code>[ ]</code>. There are also other options in indexing data, but we will keep it simple for now.</p> <p>Indexing with numeric values means specifying which elements we want to extract by their position in the vector.</p> <p>Get a single element of vector: <pre><code>x &lt;- c(10, 20, 30, 40, 50)\nx[2]\n</code></pre> <pre><code>species &lt;- c(\"species A\", \"species B\", \"species C\", \"species A\", \"species B\", \"species A\")\nspecies[3]\n</code></pre></p> <p>To extract multiple elements, we can use vector of indices: <pre><code>x &lt;- c(10, 20, 30, 40, 50)\nx[c(2, 4)]\n</code></pre></p> <p>We can also use vector assigned to variable as index: <pre><code>x &lt;- c(10, 20, 30, 40, 50)\ni &lt;- 2\nx[i]\ni &lt;- c(2, 4)\nx[i]\n</code></pre></p> <p>Tip</p> <p>Remember that you can always assign the result of any operation to a new variable</p> <pre><code>x &lt;- c(10, 20, 30, 40, 50)\ni &lt;- c(2, 4)\ny &lt;- x[i]\ny\n</code></pre> <p>Indexing with logical values works slightly differently. In this case, the vector of logical values (<code>TRUE</code> or <code>FALSE</code>) is used to select elements from the original vector. The <code>TRUE</code> values indicate which elements to extract.</p> <p><pre><code>x &lt;- c(10, 20, 30, 40, 50)\nx[x &gt; 35]\n</code></pre> <pre><code>[1] 40 50\n</code></pre></p> <p>Let's break down what happens in <code>x[x &gt; 35]</code>: <pre><code>x &lt;- c(10, 20, 30, 40, 50)\nx &gt; 35\n</code></pre> <pre><code>x &lt;- c(10, 20, 30, 40, 50)\ntf &lt;- x &gt; 35\nx[tf]\n</code></pre> The result will be the same if we directly use the logical condition inside the brackets. <pre><code>x &lt;- c(10, 20, 30, 40, 50)\nx[c(FALSE, FALSE, FALSE, TRUE, TRUE)]\n</code></pre> but this is not usually how we do it, because we can calculate the logical vector with condition <code>x &gt; 35</code> and use it directly as index. </p> <p>Technical note</p> <p>The logical index should have the same length as the vector we want to subset, but R will handle this for us. If we use shorter logical vectors, R will recycle the values.</p> <pre><code>x &lt;- c(10, 20, 30, 40, 50)\ni &lt;- c(TRUE, FALSE, TRUE)\nx[i]\n</code></pre> <p>Let\u2019s get back to the line labels (<code>[1]</code>) that appear when values are printed in the console. The number actually shows the index (position in a vector) of the first element printed on that line.</p> <p>Try executing the sequence <code>1:100</code> to see how line labels in the console work:</p> <pre><code>x &lt;- 25:125\nx\n</code></pre> <p>The nineteenth element of the sequence is <code>43</code>, which is indicated by the line label <code>[19]</code>, where <code>43</code> is printed on first position of that line.</p> <p><pre><code>x[19]\n</code></pre> <pre><code>[1] 43\n</code></pre></p>"},{"location":"data_types/#summary","title":"Summary","text":""},{"location":"data_types/#main-outcomes","title":"Main outcomes","text":"<ul> <li>understand basic data types in R</li> <li>what is vector, how to create vectors with multiple values including <code>c()</code> function and <code>:</code> operator</li> <li>how to do basic operations with vectors</li> <li>what is index and how to subset data with <code>[ ]</code></li> </ul>"},{"location":"data_types/#function-overview","title":"Function overview","text":"<ul> <li><code>typeof()</code> - type of the object</li> <li><code>as.*()</code> - conversion between data types</li> <li><code>c()</code> - combine values into vector with multiple values (elements)</li> <li><code>length()</code> - length of vector</li> <li><code>min()</code>,<code>max()</code>, <code>mean()</code>, <code>sum()</code> - calculate descriptive statistics of numeric vector</li> </ul>"},{"location":"df/","title":"Data frames","text":"<p>Data frame in R is structure similar to common tables. It is two dimensional array of values, where columns are vectors of same length and specific data type. It can be created with <code>data.frame()</code> function, or can be created by reading a table data, for example with <code>read.csv()</code> function. </p>"},{"location":"df/#creating-data-frame","title":"Creating data frame","text":"<p>For example, we can create a data frame with three columns: <code>taxon</code>, <code>sp_count</code> and <code>year</code>, and one row with values <code>\"birds\"</code>, <code>10</code> and <code>2020</code>. Just use a desired names for columns as arguments of <code>data.frame()</code> function, and assign the values to these arguments:</p> <p><pre><code>df &lt;- data.frame(taxon = \"birds\", sp_count = 10, year = 2020)\n\ndf\n</code></pre> this returns a data frame with one row and three columns</p> <pre><code>  taxon sp_count year\n1 birds       10 2020\n</code></pre> <p>Info</p> <p>note that there is also row number <code>1</code> on the left. This is not part of the data, it is property (attribute) of the data frame object, and it is called row names. We will not use row names in this course.</p> <p>As been mentioned, columns are vectors, so they can contain multiple values, but the vectors have to be of the same length. This is how we can create a data frame with multiple rows:</p> <pre><code>df &lt;- data.frame(taxon = c(\"birds\", \"reptiles\", \"mammals\", \"birds\"), sp_count = c(10, 2, 4, 15), year = c(2020, 2020, 2020, 2021))\ndf\n</code></pre> <p>it can be also written in multiple lines for better readability</p> <pre><code>df &lt;- data.frame(\n    taxon = c(\"birds\", \"reptiles\", \"mammals\", \"birds\"),\n    sp_count = c(10, 2, 4, 15),\n    year = c(2020, 2020, 2020, 2021)\n)\n</code></pre> <pre><code>     taxon sp_count year\n1    birds       10 2020\n2 reptiles        2 2020\n3  mammals        4 2020\n4    birds       15 2021\n</code></pre> <p>Note</p> <p>Also in this case the recycling rule applies: <pre><code>df_rec &lt;- data.frame(\n    taxon = c(\"birds\", \"reptiles\", \"mammals\", \"birds\"),\n    sp_count = 10,\n    year = 2020\n)\n\ndf_rec\n</code></pre> <pre><code>     taxon sp_count year\n1    birds       10 2020\n2 reptiles       10 2020\n3  mammals       10 2020\n4    birds       10 2020\n</code></pre></p> <p>Info</p> <p>Most of the time you will work with data frames created by reading tables from files. We will learn how to work with files in the Working with files, workflow lesson.</p>"},{"location":"df/#subsetting-data-using-indices","title":"Subsetting data - using indices","text":"<p>The are various ways to subset data frame with row and column names and position (index). The basic way to subset data frame is with <code>$</code> and <code>[]</code> operator as we do with vectors, but with data frames we can subset rows and columns.</p>"},{"location":"df/#operator","title":"<code>$</code> operator","text":"<p>Let's start with <code>$</code> operator. This simply returns the column (vector) by its name:</p> <pre><code>df$taxon\n</code></pre> <p><pre><code>[1] \"birds\"    \"reptiles\" \"mammals\"  \"birds\"   \n</code></pre> or</p> <pre><code>df$year\n</code></pre> <pre><code>[1] 2020 2020 2020 2021\n</code></pre> <p>Now you can quicly calculate some statistics on the column:</p> <pre><code>max(df$year)\n</code></pre> <pre><code>mean(df$sp_count)\n</code></pre> <p>We will use this a lot in filtering data during the course.</p>"},{"location":"df/#operator_1","title":"<code>[]</code> operator","text":"<p>The brackets <code>[]</code> operator is used to subset rows and columns by name or index. The basic syntax is <code>data_frame[row, column]</code>, where <code>row</code> and <code>column</code> can be name or index (numeric or logical), same as we subset vectods. If you want to subset only rows or columns, you can leave the other part empty (e.g. <code>data_frame[row, ]</code>). </p> <p>subsetting single row results in data frame with one row and all columns:</p> <pre><code>df[2,]\n</code></pre> <pre><code>     taxon sp_count year\n2 reptiles        2 2020\n</code></pre> <p>subsetting with multiple values:</p> <p><pre><code>df[c(1,3),]\n</code></pre> <pre><code>     taxon sp_count year\n1    birds       10 2020\n3  mammals        4 2020\n</code></pre></p> <pre><code>df[1:2,]\n</code></pre> <pre><code>     taxon sp_count year\n1    birds       10 2020\n2 reptiles        2 2020\n</code></pre> <p>subsetting single column results in vector with values of the column (similar to <code>$</code> operator):</p> <pre><code>df[,2]\n</code></pre> <p><pre><code>[1] 10  2  4 15\n</code></pre> or</p> <p><pre><code>df[, \"sp_count\"]\n</code></pre> <pre><code>[1] 10  2  4 15\n</code></pre></p> <p>but subsetting columns with multiple values will return data frame:</p> <p><pre><code>df[,c(1,3)]\n</code></pre> or</p> <pre><code>df[, c(\"taxon\", \"year\")]\n</code></pre> <pre><code>     taxon year\n1    birds 2020\n2 reptiles 2020\n3  mammals 2020\n4    birds 2021\n</code></pre> <p>Note</p> <p>You can also subset with single index, which will return a data frame with one column with the indexed or named column.</p> <p><pre><code>df[1]\n</code></pre> or <pre><code>df[\"taxon\"] \n</code></pre> <pre><code>    taxon\n1    birds\n2 reptiles\n3  mammals\n4    birds \n</code></pre></p> <p>getting specific value with row and column index:</p> <pre><code>df[2, 1]    \n</code></pre> <p><pre><code>[1] \"reptiles\"\n</code></pre> \"get the first two values of <code>taxon</code> column\": <pre><code>df[1:2, \"taxon\"]\n</code></pre></p> <pre><code>[1] \"birds\"    \"reptiles\"\n</code></pre> <p>Technical note: list? matrix?</p> <p>In the previous lesson, we skipped the data type list because we will explain it later in the course. When you try call function <code>typeof()</code> on data frame object, the result will be <code>\"list\"</code>. So don't be confused by this, because data frame is a special type of list, which will be explained in the detail later in the course.</p> <p><pre><code>l &lt;- list(c(\"birds\", \"reptiles\", \"mammals\", \"birds\"), c(10, 2, 4, 15), c(2020, 2020, 2020, 2021))\nl\n</code></pre> <pre><code>l &lt;- list(taxon = c(\"birds\", \"reptiles\", \"mammals\", \"birds\"), sp_count = c(10, 2, 4, 15), year = c(2020, 2020, 2020, 2021))\nl\n</code></pre></p> <p>Also simplier multi-dimensional structures exists in R. These are arrays and matrices, which are atomic vectors with two (matrix/array) or more (array) dimensions.</p> <p>matrix with 2 rows and 3 columns:</p> <pre><code>m &lt;- matrix(1:12, nrow = 4, ncol = 3)\nm\n</code></pre> <pre><code>    [,1] [,2] [,3]\n[1,]    1    5    9\n[2,]    2    6   10\n[3,]    3    7   11\n[4,]    4    8   12\n</code></pre> <p>While data.frame is a special list, its rectangular structure makes it also similiar to matrix. That's why we can subset data various ways, with <code>$</code> and single index <code>[i]</code> like list, but also with two indices <code>[row, column]</code> like matrix.</p>"},{"location":"df/#using-logical-values-for-subsetting","title":"Using logical values for subsetting","text":"<p>Most of the time you will subset a data with some condition, and you can do this with logical values in row index, same as we did it with vectors. In this case this returns only rows with position that corresponds to the position of <code>TRUE</code> value in logical vector.</p> <p>For example, if you want to subset only rows with <code>sp_count</code> greater than 5, you can do it like this:</p> <p><pre><code>df[df$sp_count &gt; 5,]\n</code></pre> <pre><code>     taxon sp_count year\n1    birds       10 2020\n4    birds       15 2021\n</code></pre> if we break it down, its like: <pre><code>condition &lt;- df$sp_count &gt; 5\ndf[condition,]\n</code></pre> where: <pre><code>condition\n</code></pre> <pre><code>[1]  TRUE FALSE FALSE  TRUE\n</code></pre></p> <p>so we subset only 1. and 4. row, because only in these rows the condition is <code>TRUE</code></p> <p>Another example, get only <code>birds</code> <code>sp_count</code>:</p> <p><pre><code>df[df$taxon == \"birds\", \"sp_count\"]\n</code></pre> <pre><code>[1] 10 15\n</code></pre> this is same as: <pre><code>birds_df &lt;- df[df$taxon == \"birds\",]\nbirds_df$sp_count\n</code></pre> <pre><code>[1] 10 15\n</code></pre> so you can calculate some statstics for <code>birds</code> only, like what is the minimum of recorded bird species in the data:</p> <p><pre><code>min(df[df$taxon == \"birds\", \"sp_count\"])\n</code></pre> or <pre><code>birds_df &lt;- df[df$taxon == \"birds\",]\nmin(birds_df$sp_count)\n</code></pre> <pre><code>[1] 10\n</code></pre></p>"},{"location":"df/#mixing-the-subsetting-methods","title":"Mixing the subsetting methods","text":"<p>You can also mix the subsetting methods</p> <p><pre><code>df$sp_count[df$taxon == \"birds\"]\n</code></pre> <pre><code>[1] 10 15\n</code></pre> <pre><code>df[df$year == 2020,]$taxon\n</code></pre> <pre><code>[1] \"birds\"    \"reptiles\" \"mammals\" \n</code></pre></p>"},{"location":"df/#inspecting-data-frame","title":"Inspecting data frame","text":"<p>The most common function to inspect objects in R is <code>str()</code>, which shows the structure of the object. It gives information about the type of object (called class, not so important for now), number of rows and columns, and data type of each column.</p> <p><pre><code>str(df)\n</code></pre> <pre><code>'data.frame':   4 obs. of  3 variables:\n $ taxon   : chr  \"birds\" \"reptiles\" \"mammals\" \"birds\"\n $ sp_count: num  10 2 4 15\n $ year    : num  2020 2020 2020 2021\n</code></pre></p> <p>Question</p> <p>Try function <code>str()</code> on other objects </p> <p>Function <code>summary()</code> gives summary based on object nature. For data frame it gives summary statistics of each column. <pre><code>summary(df)\n</code></pre> <pre><code>    taxon              sp_count          year     \n Length:4           Min.   : 2.00   Min.   :2020  \n Class :character   1st Qu.: 3.50   1st Qu.:2020  \n Mode  :character   Median : 7.00   Median :2020  \n                    Mean   : 7.75   Mean   :2020  \n                    3rd Qu.:11.25   3rd Qu.:2020  \n                    Max.   :15.00   Max.   :2021  \n</code></pre></p> <p>For quickly accessing dimensions of data frame, you can use functions<code>dim()</code>, <code>nrow()</code>, and <code>ncol()</code>/<code>length()</code>, which returns vectors with number of rows and columns, respectively:</p> <p>dimensions - rows and columns <pre><code>dim(df)\n</code></pre> <pre><code>[1] 4 3\n</code></pre> number of rows directly <pre><code>nrow(df)\n</code></pre> <pre><code>[1] 4\n</code></pre> number of columns directly <pre><code>ncol(df)\n</code></pre> <pre><code>[1] 3\n</code></pre> number of columns with <code>length()</code> (same as <code>ncol()</code>) <pre><code>length(df)\n</code></pre> <pre><code>[1] 3\n</code></pre></p> <p>Also for larger data frames, you can use <code>head()</code> and <code>tail()</code> functions to show first and last rows of data frame, the default value is <code>6</code>, but number of rows can be specified with <code>n</code> (second) argument:</p> <p>first 6 rows of data frame, which is in our case all rows</p> <pre><code>head(df)\n</code></pre> <p>first 2 rows of data frame <pre><code>head(df, n = 2)\n</code></pre></p> <p>last 2 rows of data frame <pre><code>tail(df, n = 2)\n</code></pre></p>"},{"location":"df/#editing-data-frame","title":"Editing data frame","text":"<p>Use of <code>$</code>  allows you to add new column if the column name does not exist in the data frame:</p> <p><pre><code>df\n</code></pre> <pre><code>     taxon sp_count year\n1    birds       10 2020\n2 reptiles        2 2020\n3  mammals        4 2020\n4    birds       15 2021\n</code></pre></p> <p><pre><code>df$month &lt;- 8\ndf\n</code></pre> <pre><code>     taxon sp_count year month\n1    birds       10 2020     8\n2 reptiles        2 2020     8\n3  mammals        4 2020     8\n4    birds       15 2021     8\n</code></pre></p> <p>If the column name already exists, it replace the values. Recycling rule applies here</p> <p><pre><code>df$month &lt;- c(7,8)\ndf\n</code></pre> <pre><code>     taxon sp_count year month\n1    birds       10 2020     7\n2 reptiles        2 2020     8\n3  mammals        4 2020     7\n4    birds       15 2021     8\n</code></pre></p> <p>Specific value can be also edited with row and column index:</p> <p><pre><code>df[2, 4]\n</code></pre> <pre><code>[1] 8\n</code></pre></p> <p><pre><code>df[2, 4] &lt;- 9\ndf\n</code></pre> ```     taxon sp_count year month 1    birds       10 2020     7 2 reptiles        2 2020     9 3  mammals        4 2020     7 4    birds       15 2021     8 <pre><code>or with logical values for row index. For example, you realize that birds were recorded in 2019\n\n``` r\ndf[df$taxon == \"birds\", \"year\"] &lt;- 2019\n# or\n# df$year[df$taxon == \"birds\"] &lt;- 2019\n# or\n# df[df$taxon == \"birds\",]$year &lt;- 2019\ndf\n</code></pre> <pre><code>     taxon sp_count year month\n1    birds       10 2019     7\n2 reptiles        2 2020     9\n3  mammals        4 2020     7\n4    birds       15 2019     8\n</code></pre> multiple values can be edited as well</p> <p><pre><code>df[df$taxon == \"birds\", ]$year &lt;- c(2022, 2025)\ndf\n</code></pre> <pre><code>     taxon sp_count year month\n1    birds       10 2022     7\n2 reptiles        2 2020     9\n3  mammals        4 2020     7\n4    birds       15 2025     8\n</code></pre></p>"},{"location":"df/#summary","title":"Summary","text":""},{"location":"df/#main-outcomes","title":"Main outcomes","text":"<ul> <li>understand structure of data frame</li> <li>create data frame with <code>data.frame()</code> function</li> <li>using the <code>[]</code> and <code>$</code> operators with data frames</li> </ul>"},{"location":"df/#function-overview","title":"Function overview","text":"<ul> <li><code>data.frame()</code> - create a data frame</li> <li><code>str()</code> - show structure of object</li> <li><code>summary()</code> - show summary statistics of each column</li> <li><code>dim()</code> - show dimensions of data frame</li> <li><code>nrow()</code> - show number of rows</li> <li><code>ncol()</code>/<code>length()</code> - show number of columns</li> <li><code>head()</code> - show first rows of data frame</li> <li><code>tail()</code> - show last rows of data frame</li> </ul>"},{"location":"files_workflow/","title":"Working with files, workflow","text":"<p>Warning</p> <p>This page is in state from the spring semester 25, and will undergo changes for the actual semester.</p>"},{"location":"files_workflow/#reading-and-writing-files-project-workflow","title":"Reading and writing files, project workflow","text":"<p>In this section we learn how to work with simplistic project workflow, and how to read and write processed files.</p>"},{"location":"files_workflow/#project-workflow","title":"Project workflow","text":"<p>The R is always running in specific directory called working directory. Working directory is important when you want to work with paths or files. You can use absuloute paths, but better practice is to use relative paths to the working directory. You can show the path to working direcotry with function <code>getwd()</code>, or change the path with the function <code>setwd()</code>, but its not so good practice, and its better to make habit to work with relative paths in project directory based workflow. This ensures that the code will work without changes if you move the project direcory to another place, renaming part of path, use other IDE, use Git etc. </p> <p>While wokring with the data in R, it is good practice to:</p> <ol> <li> <p>one directory - keep all files (data, scripts, outputs) in one directory (project or workspace directory) and run R from this  directory (working directory)</p> </li> <li> <p>automate as much as possible - write scripts that  reproduce the workflow, without the need to store some workspace files (<code>.RData</code>). This includes reading data, processing, writing outputs etc. </p> </li> </ol> <p>Note</p> <p>This is not necessary for working with R, but it is good practice to avoid building bad habits. In some cases, you will need to use absolute paths, i.e. when starting R project and you have dedicated directory for some general data which are often used. But try to avoid it as much as possible, since this disables the possibility of sharing the project.</p>"},{"location":"files_workflow/#setting-project-directory","title":"Setting project directory","text":"<p>When starting, just create a directory for your project, move data files to the data directory, and create scripts in the scripts directory. Example of simple project directory structure:</p> <pre><code>project_name/\n\u251c\u2500\u2500 data/\n\u251c\u2500\u2500 scripts/\n\u251c\u2500\u2500 outputs/\n</code></pre> <ul> <li>data/ - directory for all input data (<code>.csv</code>, <code>.shp</code>, <code>.gpkg</code>,<code>.tif</code>, ...)</li> <li>scripts/ - directory for R scripts</li> <li>outputs/ - directory for output files - plots, tables, ...</li> </ul> <p>Tip</p> <p>You can create this structure in RStudio by creating a new project and than creating the directories incliding files (scripts, etc.) in the Files pane.</p>"},{"location":"files_workflow/#rstudio-setting","title":"RStudio setting","text":"<ul> <li>.RData workspace - R can save the entire workspace (all objects, variables, functions, ...) to the <code>.RData</code> file, which can be    restored. I recommend to don't use the workspace, and write your scripts in a way that they recreate the worksapce.<ul> <li>option to set: Tools -&gt; Global options -&gt; General/basic tab: Workspace - Restore .RData - uncheck; .RData on exit Never</li> </ul> </li> <li>text encoding - use UTF-8 when saving files.<ul> <li>option to set: Tools -&gt; Global options -&gt; Code/Saving tab -&gt; Default text encoding: UTF-8</li> </ul> </li> <li>Working directory -  use the Project feature, which creates a project file <code>.Rproj</code> in the project    directory. Loading <code>.Rproj</code> automatically set the working directory to the project directory.<ul> <li>no option to set, jsut keep in mind that you are working in project directory, use relative paths while    working with files and save <code>.Rproj</code> (if you use RStudio)   file in the project directory</li> <li>creating project - File -&gt; New Project...</li> <li>opening existing project - File -&gt; Open Project... or File -&gt; Recent Projects</li> <li>RStudio opens last project by default, but you can change this in Tools -&gt; Global options -&gt; General/basic    tab: Default working directory - disable Restore most recently opened project at startup</li> </ul> </li> </ul>"},{"location":"files_workflow/#first-project","title":"First project","text":"<p>In this example project we write one script that reads the data, makes some simple processing and writes the output  to new file. We will work with export from DRUSOP which is digital register of central list of nature conservation  in the Czech Republic.</p> <ol> <li>Create a new project and directory (first_project or name it as you want) - this can be done in RStudio</li> <li>Create subdirectories in data, scripts and outputs - just creating directories</li> <li>Create a new script file first_script.R in the scripts directory - just creating file</li> <li>Download the data file<ul> <li>go to the https://drusop.nature.cz/ and select Maloplo\u0161n\u00e1 zvl\u00e1\u0161t\u011b chr\u00e1n\u011bn\u00e1 \u00fazem\u00ed in  the Objekty \u00fast\u0159edn\u00edho seznamu section.</li> <li>click the Export button, - check all with Ozna\u010d/Zru\u0161 V\u0160E na str\u00e1nce, select Excel (CSV) format in Form\u00e1t,  UTF-8 encoding in K\u00f3dov\u00e1n\u00ed, and click export Exportovat. This will download the file export.csv. Move this  file to the data directory.</li> </ul> </li> </ol> <p>Aim of the project:</p> <p>Perform some basic exploration of the data, and create a <code>.csv</code> table only with protected areas with area larger than 500 ha, declared from the 2020.</p>"},{"location":"files_workflow/#dataset","title":"Dataset","text":"<p>The dataset contain information about smaller specially protected areas in 4 categories: national nature reserves (NPR), nature reserves (PR), national natural monuments (NPP), and natural monuments (PP)</p>"},{"location":"files_workflow/#reading-data-and-general-exploration","title":"Reading data and general exploration","text":"<p>Our file is <code>.csv</code> file, which is simple data structure for storing tables in simple text file, see CSV on Wikipedia. You can open <code>.csv</code> in common spreadsheet editor such as MS Excel or Libre Oficce Calc. In R we can read it with the function <code>read.csv()</code>. As an argument, we pass the path to the file. The path can be absolute or relative, and it can be also url pointing to the file on some server. </p> <p><pre><code>df &lt;- read.csv(\"data/export.csv\")\n</code></pre> Now we have the data stored in the <code>df</code> object, which is <code>data.frame</code> object. Now you need to check if the data are read correctly (which is not always the case). You can show the data with calling <code>df</code> as any other object:</p> <p><pre><code>df\n</code></pre> But as you see this is not ideal. There are two functions to explore the data - <code>head()</code> and <code>str()</code> (from previous section).</p> <p><code>head()</code> returns a <code>data.frame</code> with the first 6 rows of the original data frame:</p> <pre><code>head(df)\n</code></pre> <p>Now we can se that the data is messy. Better way to explore the data is to use <code>str()</code> function, which returns the  structure of the data frame, including rows and columns count, columns data types and names, and example of first values in the columns</p> <pre><code>str(df)\n</code></pre> <p>Tip</p> <p>The <code>str()</code> and <code>head()</code> function are the most used functions for exploring the data. You can also use <code>summary()</code> function. These function are usualy executed directly in the console, but you can also use them in the script.</p> <p>Now we can see that the data are not read correctly. We have <code>2681</code> rows (observations) and only 1 column (variable). Evidently this is caused by reading data with wrong separator, because the <code>read.csv()</code> function uses comma (<code>,</code>) as  default separator, but the data are separated by semicolon (<code>;</code>).</p> <p>This and many ohter parameters can be set in the <code>read.csv()</code> function as arguments, see <code>?read.csv</code> for help.</p> <p>To set the separator, we can use the <code>sep</code> argument:</p> <pre><code>df &lt;- read.csv(\"data/export.csv\", sep = \";\")\nstr(df)\n</code></pre> <p>Strucutre of the data now looks better but still not ideal - check the column <code>Rozloha..ha</code> which have data type <code>chr</code> (character) but should be <code>num</code> (numeric). This is caused by the decimal separator, which is comma (<code>,</code>) instead of dot (<code>.</code>). This can be set in the <code>read.csv()</code> function with the <code>dec</code> argument:</p> <pre><code>df &lt;- read.csv(\"data/export.csv\", sep = \";\", dec = \",\")\nstr(df)\n</code></pre>"},{"location":"files_workflow/#exploring-and-cleaning-data","title":"Exploring and cleaning data","text":"<p>Now when we correctly read the data, we can explore them. We did some exploration with the <code>str()</code> function,  but in following exercises we will do some further exploration.</p> <p>This is not some exploration routine, we just show in this section common cases you will encounter while processing data, so you learn how to solve these basic problems.</p>"},{"location":"files_workflow/#dealing-with-na-what-is-the-mean-area-of-the-protected-areas","title":"Dealing with <code>NA</code> - What is the mean area of the protected areas?","text":"codesolution <pre><code>mean(df$Rozloha..ha)\n</code></pre> <p>returns <code>NA</code>, which indicates that there are some <code>NA</code> values in the data. </p> <p>Tip</p> <p>This can be further explored by the <code>is.na()</code> function, which returns logical vector of <code>TRUE</code> and <code>FALSE</code> values. This can be simply checked be <code>unique()</code> function (show unique values of vector), or summarized with <code>table()</code> function (counts the unique values of vector).</p> <pre><code>table(is.na(df$Rozloha..ha))\nunique(is.na(df$Rozloha..ha))\n</code></pre> <p>We can use the <code>na.rm</code> argument to remove the <code>NA</code> values from the calculation:</p> <pre><code>mean(df$Rozloha..ha, na.rm = TRUE)\n</code></pre>"},{"location":"files_workflow/#explore-the-na-value-of-the-rozlohaha-column","title":"Explore the <code>NA</code> value of the <code>Rozloha..ha</code> column","text":"<p>We know that we can perform some calculation ommiting the na with the <code>na.rm</code> argument, but its good to know what is the <code>NA</code> value in the data.</p> <p>We know that we can return logical vector of <code>TRUE</code> and <code>FALSE</code> values with the <code>is.na()</code> function, and further use this vector to subset the data frame, returning only the row with <code>NA</code> value in the <code>Rozloha..ha</code> column: </p> <p><pre><code>df[is.na(df$Rozloha..ha),]\n</code></pre> Which returns line <code>2681</code>, and as we know the <code>df</code> have <code>2681</code> rows (observations), so its the last row of the data.</p> <p>Its clear that the last row is not a valid observation, and in this case its kind of metadata from data provider, so it should be cleaned up from the data.</p>"},{"location":"files_workflow/#removing-the-row","title":"Removing the row","text":"<p>In this case there are many ways to remove the row. Here are some simple examples:</p> <ul> <li>simpy with the <code>[-2681]</code> notation, where <code>-</code> mens to exclude the row with index <code>2681</code>:</li> </ul> <p><pre><code>df[-2681, ]\n</code></pre> - with the subset of using <code>is.na()</code> function, but using <code>!</code> operator to negate (reverse) the logical vector, so it performs the opposite operation - get all rows where <code>Rozloha..ha</code> is not <code>NA</code>:</p> <pre><code>df[!is.na(Rozloha..ha), ]\n</code></pre> <ul> <li>with the subset of string of some column</li> </ul> <pre><code>df[df$K\u00f3d != \"COUNT:\", ]\n</code></pre> <p>Choose the one you like the most, and assign it to the <code>df</code> object:</p> <pre><code>df &lt;- df[!is.na(df$Rozloha..ha), ]\n</code></pre>"},{"location":"files_workflow/#dealing-with-dates","title":"Dealing with Dates","text":"<p>There are few columns with dates in the data, for example <code>Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed</code>. This column is the <code>character</code> data type, but if we want to work with dates, we have to convert it for further analyssis like counting the number of protected areas with certain year of declaration, etc.</p> <p>We can convert the column to the <code>Date</code> class with the <code>as.Date()</code> function. Or just retrieve the desired information (year) with the <code>substr()</code> function.</p> <p>We need to know how the dates looks like, so we list first, or first few dates:</p> <pre><code>df$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed[1:10]\nclass(df$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed[1:10])\n</code></pre> <p>So this date is formatted as <code>dd.mm.yyyy</code> - <code>day.month.year</code>, so we can use the <code>as.Date()</code> function with the <code>format</code> argument with <code>\"%d.%m.%Y\"</code> to convert the column to the <code>Date</code> class (in <code>YYYY-MM-DD</code> format):</p> <pre><code>as.Date(df$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed[1:10], format = \"%d.%m.%Y\")\nclass(as.Date(df$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed[1:10], format = \"%d.%m.%Y\"))\n</code></pre> <p>If we have task to find the newest protected area, we can use the <code>max()</code> function on the converted column:</p> <pre><code>max(df$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed) # nonsense, its character - text\nmax(as.Date(df$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed, format = \"%d.%m.%Y\"))\n</code></pre> <p>Converting column to the <code>Date</code> class is just replacing the values with the new values in <code>Date</code> class:</p> <p><pre><code>df$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed &lt;- as.Date(df$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed, format = \"%d.%m.%Y\")\nmax(df$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed)\n</code></pre> Now we can filter the data with the date, for example to get the protected areas declared after 2020:</p> <pre><code>d &lt;- as.Date(\"2020-01-01\")\ndf[df$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed &gt; d,]\n</code></pre>"},{"location":"files_workflow/#other-exploration","title":"Other exploration","text":""},{"location":"files_workflow/#get-the-protected-areas-with-area-larger-than-500-ha-and-category-npr","title":"Get the protected areas with area larger than 500 ha and category NPR","text":"<pre><code>df[df$Rozloha..ha &gt; 500,]\n</code></pre>"},{"location":"files_workflow/#get-the-protected-areas-with-area-larger-than-500-ha-and-category-npr_1","title":"Get the protected areas with area larger than 500 ha and category NPR","text":"<pre><code>df[df$Kategorie == \"NPR\",]\n</code></pre>"},{"location":"files_workflow/#what-is-the-total-area-of-the-protected-areas","title":"What is the total area of the protected areas?","text":""},{"location":"files_workflow/#which-protected-area-is-the-largest","title":"Which protected area is the largest?","text":""},{"location":"files_workflow/#which-category-has-the-largest-protected-area","title":"Which category has the largest protected area?","text":""},{"location":"files_workflow/#how-many-protected-areas-are-in-each-category","title":"How many protected areas are in each category?","text":""},{"location":"files_workflow/#writing-the-output","title":"Writing the output","text":"<p>As we cane read the <code>.csv</code> file, we can also creating/write it. We can use the <code>write.csv()</code> function from the <code>write.</code> family of functions. The <code>write.csv()</code> function writes the <code>data.frame</code> to the <code>.csv</code> file. </p> <pre><code>write.csv(df, \"outputs/processed_data.csv\", row.names = FALSE)\n# we use the row.names = FALSE to not write the row names to the file\n</code></pre> <p>If the task was: Create export of the protected areas with area larger than 500 ha and category NPR, the entire script can look like this:</p> <pre><code>df &lt;- read.csv(\"data/export.csv\", sep = \";\", dec = \",\")\n\ndf &lt;- df[!is.na(df$Rozloha..ha), ]\ndf$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed &lt;- as.Date(df$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed, format = \"%d.%m.%Y\")\n\nd &lt;- as.Date(\"2020-01-01\")\ndf &lt;- df[df$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed &gt; d,]\n\ndf &lt;- df[df$Rozloha..ha &gt; 500,]\ndf &lt;- df[df$Kategorie == \"NPR\",]\n\nwrite.csv(df, \"outputs/processed_data.csv\", row.names = FALSE)\n</code></pre> <p>or using the \"and\" operator <code>&amp;</code>:</p> <pre><code>df &lt;- read.csv(\"data/export.csv\", sep = \";\", dec = \",\")\n\ndf$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed &lt;- as.Date(df$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed, format = \"%d.%m.%Y\")\nd &lt;- as.Date(\"2020-01-01\")\ndf &lt;- df[!is.na(df$Rozloha..ha) &amp; df$Rozloha..ha &gt; 500 &amp; df$Kategorie == \"NPR\" &amp; df$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed &gt; d, ]\n\nwrite.csv(df, \"outputs/processed_data.csv\", row.names = FALSE)\n</code></pre>"},{"location":"files_workflow/#practice-exploration","title":"Practice exploration","text":"<p>Practice some exploration on the Zoraptera Occurrence Dataset (https://zenodo.org/records/14652555). The dataset contains information about the occurrence of the order Zoraptera. The link directly to dataset is \"https://raw.githubusercontent.com/kalab-oto/zoraptera-occurrence-dataset/refs/tags/1.1.0/zoraptera_occs.csv\"</p> task 1solution 1 <p>Read the data, and assign them to the <code>zoraptera</code> object</p> <pre><code>zoraptera &lt;- read.csv(\"https://raw.githubusercontent.com/kalab-oto/zoraptera-occurrence-dataset/refs/tags/1.1.0/zoraptera_occs.csv\")\n</code></pre> task 2solution 2 <p>How many observations and variables are in the data?</p> <p>There are <code>656</code> rows (observations) and <code>41</code> columns (variables)</p> task 3solutfion 3 <p>Is there <code>species</code> column in the data?</p> <p>There is no <code>species</code> column</p> task 4solutfion 4 <p>How many records are not identified to the species level?</p> <p><code>581</code></p> task 5solutfion 5 <p>What is the most common species in the data?</p> <p><code>Usazoros hubbardi</code></p> task 6solution 6 <p>What is the most common <code>country</code> in the data?</p> <p><code>United States of America</code></p> task 7solution 8 <p>How many records are from the <code>Fiji</code>?</p> <p><code>9</code></p>"},{"location":"functions/","title":"Functions","text":"<p>Summary of used functions in the course sorted by the order of appearance in the course. </p> <ul> <li><code>round()</code> - round a number to a specified number of decimal places</li> <li> <p><code>abs()</code> - absolute value of a number</p> </li> <li> <p><code>typeof()</code> - type of the object</p> </li> <li><code>as.*()</code> - conversion between data types</li> <li><code>c()</code> - combine values into vector</li> <li><code>length()</code> - length of vector</li> <li><code>min()</code>,<code>max()</code>, <code>mean()</code>, <code>sum()</code> - calculate descriptive statistics of numeric vector</li> </ul>"},{"location":"intro/","title":"Introduction to R","text":""},{"location":"intro/#what-is-r","title":"What is R?","text":"<ul> <li>R is a programming language for statistical computing but...</li> <li>... you can use it without any knowledge of statistics - to do data manipulation, data visualization, and more (file    handling, automatization, web scraping, ...)</li> <li>it is open-source, free and multiplatform</li> <li>https://cran.r-project.org/</li> <li>R can be used in two main ways: </li> <li>interactively writing commands in the console (command line)</li> <li>the code can be stored in scripts - files with code (<code>.R</code>, <code>.r</code>), and can be run entirely or partially</li> <li>generally, the scripts can be written in any text editor, but there are specialized software (IDE - Integrated Development Environment) to make writing and running code easier: </li> <li>the most popular IDE for R is RStudio, but recently same company (Posit)    also developes the Positron based on IDE VS Code</li> <li>other general IDEs used for R: VS Code, Vim, Emacs, Jupyter Notebook ...</li> <li>remember R \u2260 RStudio</li> <li>R - programming language (you can run R and execute R commands in terminal)</li> <li>RStudio - software application than helps you to write and run R code</li> </ul>"},{"location":"intro/#why-programming-for-spatial-data-handling","title":"Why programming for spatial data handling?","text":"<ul> <li>why write programs/scritps when I can already can do the same in Excel, QGIS, ArcGIS, ... ?</li> <li> <p>practically, you can do the same, but with programming you writing the \"reciepe\" how to do it, which can leads to:</p> <ul> <li>reproducibility - run the code again, share the workflow, collaborate when coding</li> <li>flexibility - do the same task with different data or parameters repeatedly with minimal effort</li> </ul> </li> </ul> <p>Example</p> <p>Imagine this GIS task: Get mean evelation for 1 km area around occurrence of specific species A. So the task will be  something like:</p> <ol> <li>read point vector data (shapefile, geopackage, ...)</li> <li>retrieve only points with specific attribute (species is <code>species A</code>)</li> <li>do 1 km buffer around the points</li> <li>read the raster data (DEM)</li> <li>extract raster values for the buffer areas, and calculate the mean</li> <li>write it to a file</li> </ol> <p>But what if you need...</p> <ul> <li>do this for all other species in the dataset ...</li> <li>... and for multiple buffer distances ...</li> <li>and for other 100 raster tiffs in the direcotry or on servers (monthly temperatures, percipitation, pressure, ...)</li> </ul> <p>You can also do this in desktop applications, but as you can imagine, it will be time consuming and inefficient. With writing the workflow  in R, you can easily change the parameters, set multiple values run it on multiple datasets, with minimal effort  compared to manual work.</p>"},{"location":"intro/#installation-of-r","title":"Installation of R","text":"<ul> <li>Download R from https://cran.r-project.org/<ul> <li>choose your system (Windows, macOS or Linux) and follow the instruction</li> <li>for windows: choose base distribution, than click Download R-4.x.x for Windows and follow the installation     wizard</li> </ul> </li> </ul> <p>After installation, you can run R with inbuild IDE Rgui or directly in terminal. But in the course we will use  RStudio, and I recommend this to all beginners.</p>"},{"location":"intro/#rstudio","title":"Rstudio","text":"<p>RStudio is the most popular IDE and de facto standard for R programming. It is free and open-source, and you can  download it from https://rstudio.com/products/rstudio/download/.  Just download the installer for your system and follow the installation wizard. Than you can run RStudio and start coding. </p> <p>Note</p> <p>You have to have R installed before you install RStudio.</p> <p>We won't go too much into details for now, and just show the basic interface and useful settings for start. Other settings  will be covered during the course.</p>"},{"location":"intro/#interface","title":"Interface","text":"<p>The GUI consists of four main panes, which can be customized and rearranged. But for now we will focus on two of them:</p> <ul> <li>Console - here you can write and run code interactively</li> <li>Source - here you can write and save your scripts (files with code), and also send the parts of the code to the    console</li> </ul>"},{"location":"packages/","title":"Packages","text":"<p>Warning</p> <p>This page is in state from the spring semester 25, and will undergo changes for the actual semester.</p>"},{"location":"packages/#packages","title":"Packages","text":"<p>Until this point, we relied in the in-built R functions (Base R), but in real world you will use function and classes from R extensions called packages. </p> <p>There are thousands of packages available on official repository called CRAN, but also on other repositories like Bioconductor, or git repositories (i.e. on GitHub, GitLab, Codeberg, ...), or you can install packages directly from files.</p> <p>In the course we will use mainly these two packages:</p> <ul> <li><code>sf</code> - for vector spatial data manipulation</li> <li><code>terra</code> - mainly for raster spatial data manipulation, but can handle also for vector data</li> </ul> <p>In some lesson we will also use these packages:</p> <ul> <li><code>ggplot2</code> - for plotting</li> <li><code>geodata</code> - for downloading spatial data</li> <li><code>Rczechia</code> of <code>CzechData</code>- for Czech Republic spatial data</li> </ul> <p>Note</p> <p>We will also mention <code>sp</code>,<code>raster</code> packages. They are predecessors of <code>sf</code> and <code>terra</code> packages respectively, now deprecated, but you can still encounter them in some projects </p> <p>You can find more packages used in spatial analysis in Spatial Task View on CRAN.</p>"},{"location":"packages/#installing-packages","title":"Installing packages","text":"<p>Installation of packages is easy, and can be don from R console with function <code>install.packages()</code> or with dedicated button in  GUI which runs this function fro you. </p> <p>Installation of <code>sf</code> package:</p> <pre><code>install.packages(\"sf\")\n</code></pre>"},{"location":"packages/#using-packages","title":"Using packages","text":"<p>Once installed, package can be loaded in any session using <code>library()</code> function. </p> <p>Loading <code>sf</code> package:</p> <pre><code>library(sf)\n</code></pre> <p>When writing scripts, it is good practice to load all packages at the beginning of the script.</p> <p>Info</p> <p>Sometimes you can also see use of <code>require()</code> function, which is similar to <code>library()</code>, but it returns <code>TRUE</code> or <code>FALSE</code> if the package is loaded or not. And also use of <code>::</code> operator, which is used to call functions from package without loading it, like <code>sf::st_read()</code> for using <code>st_read()</code> function from <code>sf</code> package without loading it.</p>"},{"location":"raster_intro/","title":"Raster data - introduction","text":"<p>Warning</p> <p>This page is in state from the spring semester 25, and will undergo changes for the actual semester.</p>"},{"location":"raster_intro/#raster-data","title":"Raster data","text":"<p>As with vector data, raster data can be handled with various packages. The most common package is the <code>terra</code> package, successor of the deprecated <code>raster</code> package. <code>terra</code> package is also capable process vector data, but it is not as complex as <code>sf</code> package in this way. </p> <p>Note</p> <p><code>terra</code> objects are spcific objects (S4), data are stoed in matrix/array not in data.frame. It have hidden structure and its not stored in lists like <code>sf</code> objects. To access the metadata you have to use specific functions.</p> <pre><code># install.packages(\"terra\")\nlibrary(terra)\n</code></pre>"},{"location":"raster_intro/#reading-raster-data-spatraster","title":"Reading raster data - <code>SpatRaster</code>","text":"<p><pre><code>dem &lt;- rast(\"data/eudem.tif\")\ndem\n\ncrs(dem)\next(dem)\n</code></pre> plot the raster data <pre><code>plot(dem)\n</code></pre> plot the histogram of the raster data <pre><code>hist(dem)\n</code></pre> get more bins</p> <p><pre><code>hist(dem, breaks = 100)\n</code></pre> Class <code>SpatRaster</code> can handle multiple layers (bands) of raster data. These can be accessed by <code>[[</code> operator as in lists. Layers can be stacked together simply with <code>c()</code> function, but layers have to have the same extent, resolution and crs. </p> <p><pre><code>dem2 &lt;- c(dem, dem)\ndem2\ndem2[[1]]\n</code></pre> Layers can be named, and accessed by name. </p> <p><pre><code>names(dem2) &lt;- c(\"dem1\", \"dem2\")\ndem2[[\"dem1\"]]\n</code></pre> Filtering layers can be done by <code>[[</code> operator with index including negative idenxing.</p> <p>drop the first layer: <pre><code>dem3 &lt;- dem2[[-1]]\n</code></pre> get the first layer: <pre><code>dem3 &lt;- dem2[[1]]\n</code></pre></p>"},{"location":"raster_intro/#summary-statistics","title":"Summary statistics","text":"<p>How to get mean, min, max, sum, etc. of the raster data?</p> <pre><code>mean(dem)\nmax(dem)\n</code></pre> <p>This seems not works as expected. That is because theese functions calculates tha statistics across all layers, eg. maximum value of all layers at each certain pixel position.</p> <p>To get quick statistics for each layer, you can use <code>summary</code> function. <pre><code>summary(dem)\n</code></pre></p> <p>or work with the raw values of the raster data, but take care of the <code>NA</code> values.</p> <pre><code>mean(values(dem), na.rm = TRUE)\n</code></pre>"},{"location":"raster_intro/#terrain-analysis","title":"Terrain analysis","text":"<p>function <code>terrain</code> can be used to calculate various terrain attributes from the DEM. See <code>?terrain</code> for more details.</p> <pre><code>slope &lt;- terrain(dem, \"slope\")\naspect &lt;- terrain(dem, \"aspect\")\n</code></pre> <p>stack the layers together <pre><code>dem &lt;- c(dem, slope, aspect)\n</code></pre> plot entire object <pre><code>plot(dem)\n</code></pre></p> <p>or all histograms of the slope layer <pre><code>hist(dem)\n</code></pre></p> trysolution <p>plot only the slope layer from <code>dem</code> object</p> <pre><code>plot(dem[[2]])\n# or\nplot(dem[[\"slope\"]])\n</code></pre>"},{"location":"raster_intro/#reclassification","title":"Reclassification","text":""},{"location":"raster_intro/#logical-reclassification","title":"logical reclassification","text":"<p>simply use logical operators to create new raster object with values <code>TRUE</code> and <code>FALSE</code> (1 and 0)</p> <p><pre><code>reclassified_dem &lt;- dem[[1]]  &gt; 1000\nplot(reclassified_dem)\n</code></pre> multiple conditions can be combined with logical operators <pre><code>reclassified_dem &lt;- dem[[1]] &gt; 500 &amp; dem[[1]] &lt; 550\n</code></pre></p>"},{"location":"raster_intro/#replacing-values","title":"replacing values","text":"<p>use of subsetting and logical operators can be used to replace values in the raster data. </p> <pre><code>reclassified_dem &lt;- dem[[1]]\nreclassified_dem[reclassified_dem &gt; 500] &lt;- NA\nplot(reclassified_dem)\n</code></pre> <p>Tip</p> <p>functions <code>replace</code> or <code>ifelse</code> works similar way, but can be used also for more complex operations</p> <pre><code>reclassified_dem &lt;- replace(dem[[1]], dem[[1]] &gt; 1000, 1)\nplot(reclassified_dem)\n</code></pre>"},{"location":"raster_intro/#value-reclassification","title":"value reclassification","text":"<p>Standard way to reclassify is use of <code>classify</code> function, which reclassify the raster data with reclassification matrix. The matrix has to have 3 columns, first two are the range of values and the third is the value to replace the values in the range.  </p> <p><pre><code>reclass_matrix &lt;- matrix(c(0, 500, 1,    \n                           500, 1000, 2,  \n                           1000, Inf, 3),  \n                         ncol = 3, byrow = TRUE)\n\nreclass_matrix\n</code></pre> <pre><code>reclassified_dem &lt;- classify(dem[[1]], reclass_matrix)\n</code></pre> plot the reclassified raster <pre><code>plot(reclassified_dem)\n</code></pre></p>"},{"location":"raster_intro/#map-algebra","title":"Map algebra","text":"<p>Map algebra is a way to perform operations on raster data. It is similar to vector data, but the operations are performed on the pixel values. </p> <pre><code>dem2 &lt;- dem[[1]] * 2\nplot(dem2)\n</code></pre> <pre><code>sum(dem)\n</code></pre> <p>Tip</p> <p>map algebra is commonmly used for multispectral data, eg. to calculate vegetation indices NDVI, NDWI, etc. </p>"},{"location":"raster_intro/#exercise","title":"exercise","text":"<p>Find the suitable areas for vineyards, these areas are on southern slopes (aspect between 135 and 225 degrees) with slope between 5 and 15 degrees, and elevation between 200 and 500 meters.  </p> <pre><code>dem &lt;- rast(\"/home/ok/git/orthoptera-atlas/processed_data/eudem.tif\")\nslope &lt;- terrain(dem, \"slope\")\naspect &lt;- terrain(dem, \"aspect\")\n</code></pre> <p><pre><code># Sklon mezi 5-30% (3\u201316 stup\u0148\u016f)\nsuitable_aspect &lt;- (aspect &gt;= 135) &amp; (aspect &lt;= 225)\nsuitable_slope &lt;- (slope &gt; 4) &amp; (slope &lt; 16)\nsuitable_elevation &lt;- (dem &gt;= 200) &amp; (dem &lt;= 500)\n\nsuitable_area &lt;- suitable_aspect &amp; suitable_slope &amp;  suitable_elevation\n</code></pre> If you want to keep all layers in the object, you can stack them together. </p> <p><pre><code>suitable_area &lt;- c(suitable_aspect, suitable_slope,suitable_elevation)\nplot(suitable_area)\n</code></pre> <pre><code>min(suitable_area)\nplot(min(suitable_area))\n</code></pre> get the area of the suitable areas</p> <pre><code>sum(suitable_area)\nplot(sum(suitable_area))\n</code></pre>"},{"location":"raster_intro/#writing-raster-data","title":"writing raster data","text":"<pre><code>writeRaster(suitable_area, \"outputs/suitable_area.tif\", overwrite = TRUE)\n</code></pre>"},{"location":"raster_operations/","title":"Raster data","text":"<p>Warning</p> <p>This page is in state from the spring semester 25, and will undergo changes for the actual semester.</p>"},{"location":"raster_operations/#raster-data","title":"Raster data","text":""},{"location":"raster_operations/#general-r-functions","title":"General R functions","text":""},{"location":"raster_operations/#download-data","title":"Download data","text":"<p>You can download data directliy in R using <code>download.file()</code> function. In this example we will download the CHELSA climate - BIO1 1981-2010, and predicted BIO1 2071-2100 for GFDL-ESM4 model and SSP126 scenario. Check <code>?download.file</code> for arguments and options.  </p> <pre><code>download.file(\"https://os.zhdk.cloud.switch.ch/chelsav2/GLOBAL/climatologies/1981-2010/bio/CHELSA_bio1_1981-2010_V.2.1.tif\", \"data/CHELSA_bio1_1981-2010_V.2.1.tif\")\n\ndownload.file(\"https://os.zhdk.cloud.switch.ch/chelsav2/GLOBAL/climatologies/2071-2100/GFDL-ESM4/ssp126/bio/CHELSA_bio1_2071-2100_gfdl-esm4_ssp126_V.2.1.tif\", \"data/CHELSA_bio1_2071-2100_gfdl-esm4_ssp126_V.2.1.tif\")\n</code></pre>"},{"location":"raster_operations/#listing-files","title":"Listing files","text":"<p>You can list files in any directory using <code>list.files()</code> function. With argument <code>pattern</code> you can filter the files by matching string - regular expression (regex), for example part of the name or file extension.</p> <p><pre><code>list.files()\n</code></pre> list all files in the current directory recursively</p> <pre><code>list.files(recursive = TRUE)\n</code></pre> <p>or list all files in subdirectory <code>data</code>:</p> <pre><code>list.files(\"data\")\n</code></pre> <p>get the relative path of the files :</p> <pre><code>list.files(\"data\", full.names = TRUE)\n</code></pre> <p>use <code>pattern</code> to filter the files with regex <pre><code>list.files(recursive = TRUE, pattern = \"bio\")\n</code></pre></p>"},{"location":"raster_operations/#raster-manipulation","title":"Raster manipulation","text":"<p>Task:  1. Prepare raster stack of bioclimatic CHELSA data and elevation data. The resolution of the raster stack will be 30seconds (~1km) - resolution of the CHELSA data. 2. Mask the raster stack with the DEM data. 3. Create raster of distances to the nearest 1000m elevation. 4. Save the raster stack to separate files.</p> <pre><code>library(terra)\n</code></pre> <p>read all raster files in the directory <code>data</code>:</p> <pre><code>raster_files &lt;- list.files(\"data\", pattern = \".tif$\", full.names = TRUE)\n</code></pre> <p>Note</p> <p>Notice that we used <code>pattern = \".tif$\"</code> to filter only the files with <code>.tif</code> extension. The <code>$</code> means that the string should end with <code>.tif</code>.</p> <pre><code>r &lt;- rast(raster_files)\n</code></pre> <p>Info</p> <p>Function <code>rast()</code> can read also files directly from url string.</p> <pre><code>urls &lt;- c(\n    \"https://os.zhdk.cloud.switch.ch/chelsav2/GLOBAL/climatologies/1981-2010/bio/CHELSA_bio1_1981-2010_V.2.1.tif\",\n    \"https://os.zhdk.cloud.switch.ch/chelsav2/GLOBAL/climatologies/2071-2100/GFDL-ESM4/ssp126/bio/CHELSA_bio1_2071-2100_gfdl-esm4_ssp126_V.2.1.tif\"\n    )\nr &lt;- rast(urls)\nr\n</code></pre> <p>If we want to read all raster in stack, all rasters have to have the same extent, resolution and projection. We have to preprocess the data before.</p> <p>try to read only bio1 files and dem separately</p> <pre><code>r_bio &lt;- rast(list.files(\"data\", pattern = \"bio\", full.names = TRUE))\n\nr_dem &lt;- rast(\"data/eu_dem.tif\")\n</code></pre>"},{"location":"raster_operations/#get-the-same-extent","title":"get the same extent","text":"<p>For clipping raster object to specific extent use <code>crop()</code> function. It can crop the raster with extent object, or other raster object (retrieve the extent from the other raster).</p> <p><pre><code>r_bio_cz &lt;- crop(r_bio, r_dem)\n</code></pre> Extntes do not overlap, we need to reproject the raster to the same projection.</p> <pre><code>r_dem_cz &lt;- project(r_dem, crs(r_bio))\nr_bio_cz &lt;- crop(r_bio, r_dem_cz)\n</code></pre>"},{"location":"raster_operations/#resample-to-the-same-resolution","title":"resample to the same resolution","text":"<p>see <code>?resample</code> for more options, particularly <code>method</code> argument. In our case we will use some sumary method</p> <pre><code>r_dem_cz &lt;- resample(r_dem_cz,r_bio_cz, method = \"average\")\n</code></pre>"},{"location":"raster_operations/#stack-the-rasters","title":"stack the rasters","text":"<pre><code>r_stack &lt;- c(r_bio_cz, r_dem_cz)\n</code></pre>"},{"location":"raster_operations/#masking","title":"masking","text":"<p>mask the raster stack with the DEM</p> <p><pre><code>masked_z &lt;- mask(r_stack, r_dem_cz)\nplot(masked_z)\n</code></pre> or mask all raster in stack with any NA in any raster</p> <pre><code>masked_z &lt;- mask(r_stack, anyNA(r_stack))   \n</code></pre>"},{"location":"raster_operations/#distance-to-the-nearest-1000m-elevation","title":"distance to the nearest 1000m elevation","text":"<p><code>distance()</code> function calculates the distance to the nearest non-NA cell in the raster. So we need to rewrite all values less then 1000 to NA. </p> <pre><code>dem_1000 &lt;- r_dem_cz\ndem_1000[dem_1000 &lt; 1000] &lt;- NA\nplot(dem_1000)\n</code></pre> <p><pre><code>dist_1000 &lt;- distance(dem_1000)\nplot(dist_1000)\n</code></pre> mask the distance raster with the DEM and add it to the stack</p> <pre><code>dist_1000 &lt;- mask(dist_1000, r_dem_cz)\nmasked_z &lt;- c(masked_z, dist_1000)\nplot(masked_z)\n</code></pre>"},{"location":"raster_operations/#other-exercises","title":"Other exercises","text":"<ul> <li>compare between 1981-2010 and 2071-2100, where the mean temperature is greater than 9  in the Czech Republic</li> </ul> <pre><code>r9 &lt;- c(r_bio_cz[[1]] &gt; 9, r_bio_cz[[2]] &gt; 9)\n</code></pre> <p>Advanced</p> <p>write a function that will plot the difference of these rasters with given temperature threshold.</p> <ul> <li>check how the mean temperature changes between 1981-2010 and 2071-2100 in the Czech Republic</li> </ul> <pre><code>d &lt;- r_bio_cz[[2]] - r_bio_cz[[1]]\nd\nplot(d)\n</code></pre> <p>check how mean temperature changes between 1981-2010 and 2071-2100 globally</p> <pre><code>d &lt;- r_bio[[2]] - r_bio[[1]]\nplot(d)\n</code></pre>"},{"location":"sources/","title":"Sources","text":"<p>https://cran.r-project.org/doc/manuals/r-release/R-lang.html https://ds-pl-r-book.netlify.app/</p>"},{"location":"sources/#project-workflow","title":"project workflow","text":"<ul> <li>https://rstats.wtf/projects</li> <li>https://r4ds.had.co.nz/workflow-projects.html</li> </ul>"},{"location":"sources/#packages","title":"Packages","text":"<ul> <li>https://cran.r-project.org/web/views/Spatial.html</li> </ul>"},{"location":"vector_intro/","title":"Vector data - introduction","text":"<p>Warning</p> <p>This page is in state from the spring semester 25, and will undergo changes for the actual semester.</p>"},{"location":"vector_intro/#vector-data","title":"Vector data","text":"<p>In R we can work with vector data using many packages, but the most popular and widely used is <code>sf</code> package, and we will use it in following lessons. Other packages used for spatial vector data processing are <code>stars</code> and <code>terra</code>, and discontinued <code>sp</code> and <code>raster</code> packages. Each from this packages has its own data classes, but they can be easily converted between each other, which can be useful, since some other packages may be dependent on data classes from specific package.</p>"},{"location":"vector_intro/#exercise","title":"Exercise","text":"<p>In this exercise we will work with National Parks and Protected Landscape Areas and aditionall informations (similar to previous lesson). We will read the data, explore it and create some plots.</p>"},{"location":"vector_intro/#data","title":"Data","text":"<ul> <li> <p>shapefile with National Parks and Protected Landscape Areas - download the data form here and extract it to <code>data/vzchu</code> directory.</p> </li> <li> <p>table with additional informations - similarly to previous lesson, get the <code>csv</code> table from https://drusop.nature.cz/, but this time with Velkoplo\u0161n\u00e1 zvl\u00e1\u0161t\u011b chr\u00e1n\u011bn\u00e1 \u00fazem\u00ed - National Parks and Protected Landscape Areas. Save the table to <code>data/</code> directory. </p> </li> </ul>"},{"location":"vector_intro/#reading-data-and-general-exploration","title":"Reading data and general exploration","text":"<p>Load <code>sf</code> package (if not installed, install it with <code>install.packages(\"sf\")</code> in console). So this line should be in the beginning of your script.</p> <pre><code>library(sf)\n</code></pre> <p>Read the data</p> <pre><code>vzchu &lt;- st_read(\"data/vzchu/vzchu.shp\")\n</code></pre> <p><code>read_sf</code></p> <p>there is also function <code>read_sf</code> - which is only alias for <code>st_read</code> with different default arguments. For more info see <code>?st_read</code> or <code>?read_sf</code> (similar applies for <code>write_sf</code> and <code>st_write</code>). The main noticable difference is that <code>read_sf</code> reads data as <code>sf-tibble</code> and <code>st_read</code> as <code>sf-data.frame</code>. </p> <p><code>st_layers</code></p> <p>If you work with files that can store multiple layers (like <code>geopackage</code>), you have to specify which layer to read by adding <code>layer</code> argument. To see available layers in file use <code>st_layers</code> function.</p> <p>Check the structure of the data</p> <pre><code>vzchu\n</code></pre> <pre><code>str(vzchu)\n</code></pre> <pre><code>summary(vzchu)\n</code></pre> <p><pre><code>class(vzchu)\n</code></pre> <pre><code>head(vzchu)\n</code></pre> <pre><code>names(vzchu)\n</code></pre></p> <p>You can see that the data is stored as <code>sf</code> object, which is <code>data.frame</code> with additional attributes. The <code>geometry</code> column contains the geometries of the features. </p> <p>So we can hadnle the data as <code>data.frame</code> and use many functionality we know from working with <code>data.frame</code>.</p> <p>for xample:</p> <p>get vector of unique values in column <code>KAT</code></p> <pre><code>unique(vzchu$KAT)\n</code></pre> <p>subsetting the columns to get only <code>KAT</code> and <code>NAZEV</code> columns</p> <pre><code>vzchu[,c(\"KAT\", \"NAZEV\")]\n</code></pre> <p>subsetting the rows to get only National Parks</p> <pre><code>vzchu[vzchu$KAT == \"NP\",]\n</code></pre> <p>Note</p> <p>You can drop the geometries and get plain <code>data.frame</code> without geometries and vice versa.</p> <p>drop geometries</p> <pre><code>vzchu_df &lt;- as.data.frame(vzchu)\n# or\nvzchu_df &lt;- st_drop_geometry(vzchu)\n</code></pre> <p>drop data.frame</p> <pre><code>vzchu_sfc &lt;- vzchu$geometry\n</code></pre>"},{"location":"vector_intro/#plotting","title":"Plotting","text":"<p>In this point we learn how to show simple plots of the data (spatial and non-spatial). We will use built-in <code>plot</code> function, which is able to plot <code>sf</code> objects, and try other  types of plots for data <code>barplot</code> and <code>hist</code> (histogram).</p> <p>Basic built-in plot functions are good for quick visualization or for simple plots, but later in the course we dedicate a whole lesson to more advanced plotting with <code>ggplot2</code> package and other packages for visualizations spatial data.</p> <p>plot two numeric columns</p> <pre><code>plot(vzchu$SHAPE_AREA, vzchu$SHAPE_LEN)\n</code></pre> <p>advanced</p> <p>regression line (linear model fit <code>lm</code>) can be easily added to the plot using <code>abline</code> function</p> <pre><code>area_len_lm &lt;- lm(vzchu$SHAPE_LEN ~ vzchu$SHAPE_AREA)\n\nplot(vzchu$SHAPE_AREA, vzchu$SHAPE_LEN)\nabline(area_len_lm)\n</code></pre> <p>histogram of <code>SHAPE_AREA</code> column</p> <pre><code>hist(vzchu$SHAPE_AREA)\n</code></pre> <p>simple barplot of categories in <code>KAT</code> column. There is need to count the values first with <code>table</code> function.</p> <pre><code>barplot(table(vzchu$KAT))\n</code></pre>"},{"location":"vector_intro/#plotting-sf-objects","title":"Plotting <code>sf</code> objects","text":"<p>You can use just <code>plot</code> with <code>sf</code> object, but this will plot all columns in the data (see <code>?plot.sf</code>).</p> <pre><code>plot(vzchu)\n</code></pre> <p>If you want to plot only specific column, you can use <code>plot</code> with subset using <code>[]</code> and name of single column. If you want to plot only geometries, you can use <code>plot</code> with <code>geometry</code> column.</p> <pre><code>plot(vzchu[\"KAT\"])\n</code></pre> <pre><code>plot(vzchu[\"geometry\"])\n#or\nplot(vzchu$geometry)\n#or\nplot(st_geometry(vzchu))\n</code></pre> <p>Some examples of use of subsetting for plotting data (same as with <code>data.frame</code>)</p> <p><pre><code>vzchu[vzchu$NAZEV == \"\u0160umava\",\"KAT\"]\nplot(vzchu[vzchu$NAZEV == \"\u0160umava\",\"KAT\"])\n</code></pre> <pre><code>plot(vzchu[vzchu$NAZEV == \"Beskydy\",\"geometry\"])\n</code></pre></p> <pre><code>plot(vzchu[vzchu$NAZEV == \"Labsk\u00e9 p\u00edskovce\",\"geometry\"])\n</code></pre> <p>Do you remeber the difference of <code>[]</code> and <code>$</code> operators?</p> <p><code>[]</code> - keeping classes, with <code>list</code> this returns <code>list</code>, with <code>data.frame</code> returns the <code>data.frame</code>, and now with <code>sf</code> object - returns <code>sf</code> object</p> <p><pre><code>vzchu[\"SHAPE_AREA\"]\nclass(vzchu[\"SHAPE_AREA\"])\n</code></pre> thus plot use <code>sf</code> object</p> <pre><code>plot(vzchu[\"SHAPE_AREA\"])\n</code></pre> <p><code>$</code> - subset which always returns the data as <code>numeric</code> vector</p> <p><pre><code>vzchu$SHAPE_AREA\nclass(vzchu[\"SHAPE_AREA\"])\n</code></pre> plot use <code>numeric</code> vector</p> <pre><code>plot(vzchu$SHAPE_AREA)\n</code></pre> <p>but! you can use <code>$</code> with <code>sf</code> object to get spatial data (<code>sfc</code> class) with the <code>geometry</code> column, since it is special <code>sfc</code> class column (see <code>str(vzchu)</code> above)</p> <p><pre><code>vzchu$geometry\nclass(vzchu$geometry)\n</code></pre> thus plotting:</p> <p><pre><code>plot(vzchu[\"geometry\"])\nplot(vzchu$geometry) # same as `plot(st_geometry(vzchu))`\n</code></pre> looks the same, but the first one is <code>sf</code> object and the second one is <code>sfc</code> object</p>"},{"location":"vector_intro/#spatial-proeprties","title":"Spatial proeprties","text":"<p>Now we will explore some spatial properties of the data.</p>"},{"location":"vector_intro/#geometry-type","title":"Geometry type","text":"<pre><code>st_geometry_type(vzchu)\n</code></pre> <p>geometry type can be converted with <code>st_cast</code> function. For example whe have <code>MULTIPOLYGON</code> (multi-part features) and we want to convert it to <code>POLYGON</code> (single-part features).</p> <pre><code>st_cast(vzchu, \"POLYGON\")\n</code></pre> <p>Note</p> <p><code>st_cast</code> can be useful if you have mixed geometry types, typically multi-part features with single-part features., then you can convert all of them to multi-part features.</p>"},{"location":"vector_intro/#bounding-box","title":"bounding box","text":"<p>Bounding box is the rectangle that encloses all the geometries in the data.</p> <pre><code>st_bbox(vzchu)\nclass(st_bbox(vzchu))\n</code></pre>"},{"location":"vector_intro/#crs-coordinate-reference-system","title":"CRS - coordinate reference system","text":"<p>See the definition of the coordinate reference system (CRS) </p> <pre><code>st_crs(vzchu)\nclass(st_crs(vzchu))\n</code></pre> <p>You can transform <code>sf</code> data to other CRS with <code>st_transform</code> function. For example we can change the CRS to WGS84 (EPSG:4326)</p> <p><pre><code>st_transform(vzchu, 4326)\n</code></pre> notice the transformed geometry column</p>"},{"location":"vector_intro/#basic-spatial-calculations","title":"Basic spatial calculations","text":"<p>Here we will calculate the area and the perimeter of the features.</p> <p><code>st_area</code> - calculate the area</p> <pre><code>st_area(vzchu)\n</code></pre> <p><code>st_periemeter</code> - calculate the perimeter</p> <pre><code>st_perimeter(vzchu)\n</code></pre> <p>add the area and perimeter to the data</p> <pre><code>vzchu$area &lt;- st_area(vzchu)\nvzchu$perimeter &lt;- st_perimeter(vzchu)\nvzchu$shape &lt;- st_perimeter(vzchu)/st_area(vzchu)\n</code></pre>"},{"location":"vector_intro/#joining-attribute-data-dataframe","title":"Joining attribute data (<code>data.frame</code>)","text":"<p>Now we will join the additional informations from the table to the <code>sf</code> object. We will use <code>merge</code> function, which is used for merging data frames. In this example we will join the information about the date of the first declaration of the National Park or Protected Landscape Area, and minimum elevation.</p> <pre><code>df &lt;- read.csv(\"data/export.csv\")\n</code></pre> <p>Since this is similar data as last lesson, we can see similar problems. We resolve this using the part of the code from last lesson.</p> <pre><code>df &lt;- read.csv(\"data/export.csv\", sep = \";\", dec = \",\")\n\ndf &lt;- df[!is.na(df$Rozloha..ha), ]\ndf$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed &lt;- as.Date(df$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed, format = \"%d.%m.%Y\")\n</code></pre> <p>Before join, we have to check the column names  <pre><code>str(df)\nstr(vzchu)\n</code></pre></p> <p>filter out desired columns <pre><code>df &lt;- df[,c(\"K\u00f3d\", \"Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed\", \"Nadmo\u0159sk\u00e1.v\u00fd\u0161ka.min.\")]\n</code></pre></p> <pre><code>vzchu &lt;- merge(vzchu, df, by.x = \"KOD\", by.y = \"K\u00f3d\")\n</code></pre> <pre><code>vzchu\n</code></pre> <p>plot the results</p> <pre><code>plot(vzchu[\"Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed\"])\n</code></pre> <pre><code>plot(vzchu[\"Nadmo\u0159sk\u00e1.v\u00fd\u0161ka.min.\"])\n</code></pre>"},{"location":"vector_intro/#writing-data","title":"Writing data","text":""},{"location":"vector_operations/","title":"Vector data","text":"<p>Warning</p> <p>This page is in state from the spring semester 25, and will undergo changes for the actual semester.</p>"},{"location":"vector_operations/#vector-geometry-operations-and-analysis","title":"Vector geometry operations and analysis","text":"<p>data for this lesson</p> <pre><code>library(sf)\nclc &lt;- st_read(\"data/CLC18_CZ.shp\")\nvzchu &lt;- st_read(\"data/vzchu.shp\")\nmantis &lt;- read.csv(\"data/observations-537954.csv\")\n</code></pre>"},{"location":"vector_operations/#creating-sf-objects-from-coordinate-data-dataframe","title":"Creating <code>sf</code> objects from coordinate data (<code>data.frame</code>)","text":"<pre><code>mantis_sf &lt;- st_as_sf(mantis, coords = c(\"longitude\", \"latitude\"), crs = 4326)\nmantis_sf &lt;- st_transform(mantis_sf, 5514)\nplot(mantis_sf$geometry)\n</code></pre>"},{"location":"vector_operations/#spatial-join","title":"Spatial join","text":"<p>How many mantis observations are in NP and PLA?</p> <pre><code>st_join(mantis_sf, vzchu)\n#or\nst_intersection(mantis_sf, vzchu)\n</code></pre> <p>In which land cover class are the mantis observations most often?</p> <pre><code>st_join(mantis_sf, clc)\n</code></pre> <pre><code>st_crs(clc) &lt;- st_crs(mantis_sf) #or st_transform(clc, st_crs(vzchu))\nmantis_clc &lt;- st_join(mantis_sf, clc)\n</code></pre> <pre><code>mantis_clc$CODE_18\ntable(mantis_clc$CODE_18) \nsort(table(mantis_clc$CODE_18),decreasing = T)\n</code></pre>"},{"location":"vector_operations/#spatial-operations","title":"Spatial operations","text":"<p>We will use the <code>Beskydy</code> region as an example.</p> <pre><code>beskydy &lt;- vzchu[vzchu$NAZEV == \"Beskydy\", \"geometry\"]\nplot(beskydy)\n</code></pre>"},{"location":"vector_operations/#subsetting","title":"subsetting","text":"<p>subsetting points - How many mantis observations are in PLA Beskydy?</p> <p><pre><code>mantis_beskydy &lt;- mantis_sf[beskydy,]\nmantis_beskydy\nplot(beskydy$geometry)\nplot(mantis_beskydy$geometry, add = TRUE)\n</code></pre> or using <code>st_intersection</code> function</p> <pre><code>mantis_beskydy &lt;- st_intersection(mantis_sf, beskydy)\nplot(beskydy$geometry)\nplot(mantis_beskydy$geometry, add = TRUE)\n</code></pre> <p>subsetting polygons</p> <pre><code>clc_beskydy &lt;- clc[beskydy,]\nplot(clc_beskydy$geometry)\nplot(beskydy$geometry, border = \"red\", add = T, lwd = 2)\n</code></pre>"},{"location":"vector_operations/#clip","title":"clip","text":"<p>What is the most common land cover class in Beskydy?</p> <pre><code>clc_beskydy &lt;- st_intersection(beskydy, clc)\nplot(clc_beskydy$geometry)\nplot(beskydy$geometry, border = \"red\", add = T, lwd = 2)\ntable(clc_beskydy$CODE_18)\nsort(table(clc_beskydy$CODE_18), decreasing = T)\n</code></pre> <p>What is the area of each land cover class in Beskydy?</p> <ol> <li>sum the <code>data.frame</code> area column with <code>aggregate</code> function</li> </ol> <pre><code>aggregate(x = clc_beskydy$Area_Ha, by = list(clc_beskydy$CODE_18), FUN = sum)\n</code></pre> <ol> <li>aggregate the <code>sf</code> object area column with <code>aggregate</code> function</li> </ol> <pre><code>clc_beskydy_ag &lt;- aggregate(clc_beskydy, list(clc_beskydy$CODE_18), sum)\n</code></pre>"},{"location":"vector_operations/#buffer","title":"buffer","text":"<p>What is the area of each land cover class in 1km buffer around the mantis observations?</p> <pre><code>buffer_mantis &lt;- st_buffer(mantis_beskydy, 1000)\nplot(buffer_mantis$geometry)\n</code></pre> <p><pre><code>clc_buffer_mantis &lt;- st_intersection(clc,buffer_mantis)\n</code></pre> overlapping polygons <pre><code>overlapping_polygons &lt;- st_overlaps(clc_buffer_mantis)\noverlapping_polygons &lt;- clc_buffer_mantis[unlist(overlapping_polygons),]\nplot(overlapping_polygons[\"CODE_18\"])\n</code></pre> use <code>st_union</code> to merge overlapping buffer polygons (similar to <code>dissolve</code> in desktop GIS)</p> <pre><code>clc_buffer_mantis &lt;- st_union(clc_buffer_mantis)\nclc_buffer_mantis &lt;- st_intersection(clc,buffer_mantis)\n</code></pre> <pre><code>aggregate(x = st_area(clc_buffer_mantis), by = list(clc_buffer_mantis$CODE_18), FUN = sum)\n</code></pre>"},{"location":"vector_operations/#centroid","title":"centroid","text":"<pre><code>centroid_vzchu &lt;- st_centroid(vzchu)\nplot(vzchu$geometry, col = \"grey\")\nplot(centroid_vzchu$geometry, col = \"red\", add = TRUE)\n</code></pre>"},{"location":"vector_operations/#convex-hull-mcp-home-range","title":"convex hull (mcp home range)","text":"<pre><code>hull_mantis &lt;- st_convex_hull(st_union(mantis_beskydy))\nplot(hull_mantis, col = \"grey\")\nplot(mantis_beskydy$geometry, col = \"red\", add = TRUE)\n</code></pre>"},{"location":"vector_operations/#distance","title":"distance","text":"<p>distance matrix <pre><code>mantis_distances &lt;- st_distance(mantis_sf, vzchu)\nhead(mantis_distances)\n</code></pre></p>"},{"location":"vector_operations/#compute-the-most-distant-mantis-observation-to-any-protected-area","title":"Compute the most distant mantis observation to any protected area","text":"<pre><code>mantis_distances &lt;- st_distance(mantis_sf, vzchu)\nmax(mantis_distances)\nhist(mantis_sf$max_distance)\n</code></pre>"},{"location":"vector_operations/#distance-compute-the-nearest-distance-from-each-mantis-observation-to-the-nearest-protected-area","title":"distance: Compute the nearest distance from each mantis observation to the nearest protected area","text":"<p>apply family of functions (apply, lapply)</p> <p>Info</p> <p><code>apply</code> function applies a function to the rows or columns of a matrix or array.  <code>lapply</code> function applies a function to each element of a list or vector.</p> <p><pre><code>m &lt;- matrix(1:9, nrow = 3)\nm\napply(m, 1, sum)\napply(m, 2, sum)\n</code></pre> <pre><code>l &lt;- list(10:50,6:10,45:100)\nl\nlapply(l, mean)\n</code></pre></p> <pre><code>mantis_distances &lt;- st_distance(mantis_sf, vzchu)\nmantis_sf$min_distance &lt;- apply(mantis_distances, 1, min)\nhist(mantis_sf$min_distance, breaks = 20, main = \"Distance to Nearest Protected Area\", xlab = \"Distance (m)\")\n</code></pre>"},{"location":"vector_operations/#exercise-append-land-cover-areas-to-mantis-data","title":"Exercise: Append Land Cover Areas to Mantis Data","text":"<pre><code>mantis_beskydy &lt;- mantis_sf[beskydy,]\nclc_beskydy &lt;- clc[beskydy,]\n\nbuffer_mantis &lt;- st_buffer(mantis_beskydy, 1000)\n\nclc_buffer_mantis &lt;- st_intersection(clc,buffer_mantis)\n\n\nclc_buffer_mantis$area &lt;- st_area(clc_buffer_mantis)\n\n# Aggregate areas by mantis observation and land cover class\nmantis_clc_areas &lt;- aggregate(clc_buffer_mantis$area,\n                              by = list(mantis_id = clc_buffer_mantis$id,\n                                        CODE_18 = clc_buffer_mantis$CODE_18),\n                              FUN = sum)\n\n# Reshape to wide format and merge with mantis dataset\nmantis_clc_wide &lt;- reshape(mantis_clc_areas, idvar = \"mantis_id\", timevar = \"CODE_18\", direction = \"wide\")\n\nmantis_sf &lt;- merge(mantis_sf, mantis_clc_wide, by.x = \"id\", by.y = \"mantis_id\", all.x = TRUE)\n</code></pre>"},{"location":"vector_operations/#summary","title":"Summary","text":""},{"location":"vector_operations/#new-functions","title":"New functions","text":""},{"location":"vector_operations/#base-r","title":"Base R","text":"<ul> <li><code>merge()</code></li> <li><code>apply()</code></li> <li><code>reshape()</code></li> </ul>"},{"location":"vector_operations/#sf","title":"<code>sf</code>","text":"<ul> <li><code>st_buffer()</code></li> <li><code>st_centroid()</code></li> <li><code>st_convex_hull()</code></li> <li><code>st_distance()</code></li> </ul>"}]}