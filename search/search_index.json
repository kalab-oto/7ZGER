{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction to Geospatial Data Processing in R","text":"<p>Materials for the course KFG/7ZGER - Introduction to Geospatial Data Processing in R taught at the Department of Physical Geography and Geoecology of the University of Ostrava. The course is intended for students of envionmental geography.</p> <p>Warning</p> <p>The materials are inconsistent and incomplete. They primarily serve to summarize individual exercises to facilitate orientation in the course during self-study. For detailed information, it is necessary to attend the exercises or seek information in the recommended sources.</p>"},{"location":"#moodle","title":"Moodle","text":"<p>The current year's course is conducted on Moodle, where information for individual exercises and especially assignments can be found:</p> <p>KFG/7ZGER - Spring semester 24/25</p>"},{"location":"#other-courses","title":"Other courses","text":""},{"location":"basics/","title":"R Basics","text":""},{"location":"basics/#r-as-a-calculator","title":"R as a calculator","text":"<pre><code>1 + 1\n</code></pre> <pre><code>[1] 2\n</code></pre> <p>use <code>**</code> or <code>^</code> for exponentiation</p> <pre><code>5 * 5 / (3 + 10)\n5**2 / (3 + 10)\n</code></pre>"},{"location":"basics/#comparsion","title":"Comparsion","text":"<p>You can also test if values meets some condition</p> <ul> <li><code>==</code> - equals</li> <li><code>!=</code> - not equals</li> <li><code>&gt;</code> - greater than</li> <li><code>&lt;</code> - less than</li> <li><code>&gt;=</code> - greater or equal</li> <li><code>&lt;=</code> - less or equal</li> </ul> <pre><code>5 == 5\n</code></pre> <pre><code>[1] TRUE\n</code></pre> <p>try: <pre><code>5 &gt; 10\n6 != 6\n10 &lt;= 10\n8 &gt; 2 * 3\n</code></pre></p>"},{"location":"basics/#variables","title":"Variables","text":"<p>Values and objects can be stored in variables with assigment operator <code>&lt;-</code> (or <code>=</code>), but <code>&lt;-</code> is more common, and will be used in this course. Calling the variable name will return the value stored in it.</p> <pre><code>x &lt;- 42\n\nx\n</code></pre> <pre><code>[1] 42\n</code></pre> <pre><code>x &lt;- 7\ny &lt;- 6\n\ny * x\n</code></pre> <p>Assigning a value to existing variable will overwrite the previous value.</p> <pre><code>x &lt;- 7\ny &lt;- 6\nx &lt;- 2\n\ny * x\n</code></pre> <p>try: <pre><code>x &lt;- 5\ny &lt;- 10\nz &lt;- x + y\nz\n</code></pre></p> <p>Variables names:</p> <ul> <li>can't contain spaces and special characters</li> <li>can't start with number</li> <li>are case sensitive</li> <li>can't be some reserved words (<code>if</code>, <code>for</code>, ...)</li> </ul> <pre><code>variable1 &lt;- 5\nvariable1\n</code></pre> <p><pre><code>1variable &lt;- 5\n1variable\n</code></pre> The convention is to use descriptive but not excessive long variable names. There are tree main types of naming in R:</p> <ul> <li>snake_case - used in this course</li> <li>camelCase</li> <li>dot.case</li> </ul> <p>Use what you like, but be consistent.</p> <pre><code>my_variable &lt;- 5\nmy_variable\n</code></pre>"},{"location":"basics/#functions","title":"Functions","text":"<p>Calling function consist of function name and arguments in parentheses. Arguments can be named or unnamed.  <code>function_name(argument1 = value1 ,argument2 = value2, argument3 = value3, ...)</code>. Some functions doesn't have  any arguments (<code>getwd()</code>).</p> <p><pre><code>sin(5)\nsqrt(25)\n</code></pre> You can get function help using RStudio GUI or calling <code>?</code> before the function name, or <code>help()</code> function.</p> <pre><code>?sqrt\n</code></pre>"},{"location":"basics/#writing-scripts","title":"Writing scripts","text":"<p>As mentioned in the Introduction to R there are various ways to write and run code in R, interacively in the console, or writing scripts that can be saved and run later (entire or by parts). Most of the time you will write code to scripts (<code>.R</code> or <code>.r</code> files). Code can be written in any text editor.</p>"},{"location":"basics/#runing-code","title":"Runing code","text":"<p>In RStudio you can write and save scripts in the Source pane. You can run the entire script or just the selected part of the code. </p> <ul> <li> <p>Run selected part of the code - <code>Ctrl + Enter</code> - or button <code>Run</code> - this you willl use mostly in this course. You can run the code line by line, or by selected blocks. This function sends the code to the console and run it, and the cursor will move to the next line or executable part of code.</p> </li> <li> <p>Run entire script - <code>Ctrl + Shift + S</code> - or button <code>Source</code> - this use a <code>source()</code> function, and run entire script (as file) in console.</p> </li> </ul>"},{"location":"basics/#comments","title":"Comments","text":"<p>In writing scripts you can \"comment\" lines. Commented lines starts with <code>#</code> and are not executed (even if they are sent to the console). Coments are useful for documenting/explanation code or \"deactivating\" parts of code.</p> <pre><code># Do some math\nx &lt;- 5\ny &lt;- 8\n# y &lt;- 10\n\nx + y\n</code></pre>"},{"location":"data/","title":"Data","text":""},{"location":"data_types/","title":"Data structures","text":""},{"location":"data_types/#data-object-types","title":"Data object types","text":"<p>primary (atomic) types in R:</p> <ul> <li>double - decimal and real numbers</li> <li>integer - whole numbers</li> <li>character - text</li> <li>logical - TRUE or FALSE</li> <li>(complex - complex numbers)</li> </ul> <p>Note</p> <p>Object can have an attributes - properties like <code>class</code>, <code>length</code>, <code>names</code>, <code>dim</code>, <code>attributes</code>, that can called or set with with some functions like <code>class()</code>, <code>length()</code>, <code>names()</code>, <code>dim()</code>, <code>attributes()</code>.</p> <p>Check the type of the object with <code>typeof()</code> function. This returns the low level datatype of the object sotred in memory.</p> <pre><code>some_text &lt;- \"Hello, world!\"\ntypeof(some_text)\n</code></pre> <pre><code>[1] \"character\"\n</code></pre> <pre><code>x &lt;- 5 == 5\ntypeof(x)\n</code></pre> <p><pre><code>[1] \"logical\"\n</code></pre> <pre><code>x &lt;- \"5\"\ntypeof(x)\n</code></pre></p> <p><pre><code>[1] \"character\"\n</code></pre> Conversion between classes can be done with <code>as.</code> functions. <pre><code>\"5\" + 5\nx &lt;- as.numeric(\"5\")\nx + 5\n</code></pre></p>"},{"location":"data_types/#data-structures_1","title":"Data structures","text":"<ul> <li>vector - one dimensional sequence of values of the same class</li> <li>matrix - two dimensional </li> <li>array - multi-dimensional</li> <li>data.frame - two dimensional array of values, values can be different classes</li> <li>list - collection of objects, can be different classes</li> <li>factor - vector of categorical values</li> </ul> <p>In this course we will mainly work with vectors, data frames and lists in less or more complex structures.</p>"},{"location":"data_types/#atomic-vectors","title":"Atomic vectors","text":"<p>Most basic data structure in R. Sequence of data of same type. Can be created by concatenating values using <code>c()</code> function (mostly used), or creating empty vector with <code>vector()</code> function. Lot of functions also returns vectors (like <code>seq()</code>). Atomic vectors are usually refered as vectors.</p> <pre><code>c(1, 15, 4, 6)\n</code></pre> <p><pre><code>[1]  1 15  4  6\n</code></pre> make a sequence of numbers with <code>seq()</code> function and arguments <code>from</code>, <code>to</code>, <code>by</code>: <pre><code>seq(1, 10, by = 2)\n</code></pre></p> <p><pre><code>[1] 1 3 5 7 9\n</code></pre> or with <code>:</code> operator: <pre><code>1:10\n</code></pre></p> <p><pre><code>[1]  1  2  3  4  5  6  7  8  9 10\n</code></pre> sequence of characters:</p> <pre><code>c(\"a\", \"b\", \"c\")\n</code></pre> <pre><code>[1] \"a\" \"b\" \"c\"\n</code></pre> <p>Vectors can't contain values of different types, various classes well be converted, see <code>?c</code>.</p> <pre><code>c(\"123\", 456, TRUE)\n</code></pre> <pre><code>[1] \"123\"  \"456\"  \"TRUE\"\n</code></pre> <p>Info</p> <p>The number at the beginning of the line <code>[1]</code> is the index (oreder number) of the first element on the terminal line. It can be useful later when we will work with more complex data and use subsetting.</p> <p>try: <pre><code>seq(1, 1000, by= 5)\n</code></pre></p> <p>You can do calculaion with vectors. <pre><code>x &lt;- c(1, 2, 3, 4)\nx * 5\n</code></pre></p> <pre><code>[1]  5 10 15 20\n</code></pre> <p>You can do operations with vectors of the same length.</p> <pre><code>x &lt;- c(1, 2, 3, 4)\ny &lt;- c(5, 6, 7, 8)\n\nx + y\n</code></pre> <pre><code>[1]  6  8 10 12\n</code></pre> <p>Adding element to vector:</p> <pre><code>x &lt;- c(\"a\", \"b\", \"c\")\nx\n\nx &lt;- c(x, \"d\")\nx\n</code></pre> <p>Function <code>length()</code> returns the length of the vector (value of attribute length).</p> <pre><code>x &lt;- c(1, 2, 3, 4)\nlength(x)\n</code></pre> <pre><code>[1] 4\n</code></pre> <p>Note</p> <p>You can also use attribute <code>name</code> and assign names to vector elements. <pre><code>x &lt;- c(1, 2, 3, 4)\nx\n\nnames(x) &lt;- c(\"first\", \"second\", \"third\", \"fourth\")\nx\nattributes(x)\n</code></pre> or simply: <pre><code>x &lt;- c(first = 1, second = 2, third = 3, fourth = 4)\nx\nattributes(x)\n</code></pre></p> <p>Function <code>sum()</code> returns the sum of the vector. <pre><code>x &lt;- c(1, 2, 3, 4)\nsum(x)\n</code></pre></p> <pre><code>[1] 10\n</code></pre> <p>try: <pre><code>x &lt;- c(5, 8, 13, 51)\nmean(x)\nmin(x)\nmax(x)\ntypeof(x)\n\ny &lt;- c(1, 2, \"c\", \"4\")\nmean(y)\n</code></pre></p> <p>Function <code>str()</code> returns the structure of object. This is useful for more complex objects, but you can use it for vectors too. <pre><code>x &lt;- c(5, 8, 13, 51)\nstr(x)\n</code></pre></p>"},{"location":"data_types/#matrix-and-arrays","title":"Matrix and arrays","text":"<p>We wont't use them much in this course, so I describe them only briefly. They are similar to vectors (technically they are vectors with <code>dim</code> attribute), but with two or more dimensions. Matrix is two dimensional, array is multi-dimensional. You can create them with <code>matrix()</code> and <code>array()</code> functions.</p> <pre><code>m &lt;- matrix(1:6, nrow = 2, ncol = 3)\nm\n</code></pre> <pre><code>     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n</code></pre> <p><pre><code>a &lt;- array(1:12, dim = c(2,3,2))\na\n</code></pre> <pre><code>, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    7    9   11\n[2,]    8   10   12\n</code></pre></p> <p>Vectors, matrices and arrays can be converted.  Try:</p> <pre><code>a &lt;- array(1:12, dim = c(2,3,2))\nc(a)\nm &lt;- matrix(1:6, nrow = 2, ncol = 3)\nc(m)\nv &lt;- 1:10\ndim(v) &lt;- c(2,5)\nv\nv2 &lt;- c(1:12)\ndim(v2) &lt;- c(2,3,2)\n</code></pre>"},{"location":"data_types/#lists","title":"Lists","text":"<p>Also vectors - collection of objects, which can be different classes. Can be created with <code>list()</code> function. This is fundamental data structure in R, and you can store any objects in it, for example another list.</p> <pre><code>my_list &lt;- list(1, \"a\", TRUE)\nmy_list\n</code></pre> <p>nesting lists: <pre><code>my_list &lt;- list(1, \"a\", TRUE)\nnested_list &lt;- list(my_list, 2, \"b\", FALSE)\nnested_list\n</code></pre></p> <p>list can be named <pre><code>named_list &lt;- list(number = 1, text = \"a\", boolean = TRUE)\nnamed_list\n</code></pre></p>"},{"location":"data_types/#data-frame","title":"Data frame","text":"<p>Data frames in R is structure similar to common tables. It is two dimensional array of values, where columns can be different classes. It can be created with <code>data.frame()</code> function. In next section we will learn how to create a data frame from <code>.csv</code> table with <code>read.csv()</code> function. Another representation of data frame is <code>tibble</code> from <code>tidyverse</code>, or <code>data.table</code> from <code>data.table</code> package, but we will use <code>data.frame</code> through the course.</p> <pre><code>df &lt;- data.frame(species = \"species A\", count = 5, year = 2020)\ndf\n</code></pre> <pre><code>df &lt;- data.frame(species = c(\"species A\",\"species B\",\"species C\"), count = c(5,10,7), year = c(2020,2020,2020))\ndf\n\nclass(df)\nstr(df)\n\ntypeof(df)\n</code></pre>"},{"location":"data_types/#subsetting-data-with-and","title":"Subsetting data with <code>[ ]</code>, <code>[[ ]]</code> and <code>$</code>","text":"<p>Subsetting is basic operation which is used to extract part of the data. You can subset data with brackets <code>[ ]</code>, <code>[[ ]]</code> or <code>$</code> operator.</p>"},{"location":"data_types/#brackets-and","title":"brackets <code>[ ]</code> and <code>[[ ]]</code>","text":"<p>Single brackets are used to subset vectors, lists, matrices and arrays. You can subset data by index:</p>"},{"location":"data_types/#subsetting-vectors","title":"Subsetting vectors","text":"<pre><code>v &lt;- c(123,789,451,657)\n</code></pre> <pre><code>v[3]\n</code></pre> <pre><code>[1] 451\n</code></pre> <p>You can subset data also by logical vector. In this example we want only values greater than 500:</p> <pre><code>v[v &gt; 500]\n# sames as\n# v[c(FALSE, TRUE, FALSE, TRUE)]\n# just we calculate the vector of logical values with\n# v &gt; 500\n</code></pre> <pre><code>[1] 789 657\n</code></pre> <p>You can subset data also by names:</p> <p><pre><code>v &lt;- c(first = 123, second = 789, third = 451, fourth = 657)\nv[\"third\"] # returns vector\n</code></pre> <pre><code>third \n  451  \n</code></pre></p> <p><pre><code>v[[\"third\"]] # also returns vector, but drop names\n</code></pre> <pre><code>[1] 451\n</code></pre></p>"},{"location":"data_types/#subsetting-lists","title":"Subsetting lists","text":"<p>If we have this list: <pre><code>my_list &lt;- list(1, \"a\", TRUE, c(123,456,789))\n</code></pre></p> <p>Single brackets <code>[ ]</code> returns list of subsetted data: <pre><code>my_list[2] \n</code></pre></p> <p><pre><code>[[1]]\n[1] \"a\"\n</code></pre> <pre><code>my_list[4] \n</code></pre></p> <p><pre><code>[[1]]\n[1] 123 456 789\n</code></pre> <pre><code>class(my_list[4])\n</code></pre></p> <p><pre><code>[1] \"list\"\n</code></pre> Double brackets <code>[[ ]]</code>returns the vector of subsetted data : <pre><code>my_list[[2]]\n</code></pre> <pre><code>[1] \"a\"\n</code></pre> <pre><code>my_list[[4]]\n</code></pre> <pre><code>[1] 123 456 789\n</code></pre> <pre><code>class(my_list[[4]])\n</code></pre></p> <p><pre><code>[1] \"numeric\"\n</code></pre> Brackets can be used subsequently: <pre><code>my_list[[4]][2]\n</code></pre> <pre><code>[1] 456\n</code></pre></p>"},{"location":"data_types/#subsetting-dataframe","title":"Subsetting data.frame","text":"<p>same as lists, but you can also subset row and column, sperated by comma:</p> <pre><code>df &lt;- data.frame(species = c(\"species A\",\"species B\",\"species C\"), count = c(5,10,7), year = c(2020,2020,2020))\ndf\n</code></pre> <pre><code>    species count year\n1 species A     5 2020\n2 species B    10 2020\n3 species C     7 2020\n</code></pre> <p>Subset column: <pre><code>df[\"species\"] #or df[1]\n</code></pre></p> <p><pre><code>    species \n1 species A \n2 species B \n3 species C \n</code></pre> Subset column returnig vector:</p> <pre><code>df[[\"species\"]] #or df[[1]]df$species\n</code></pre> <p><pre><code>[1] \"species A\" \"species B\" \"species C\"\n</code></pre> Subset rows:</p> <pre><code>df[2,]\n</code></pre> <p><pre><code>    species count year\n2 species B    10 2020\n</code></pre> Subset row and column:</p> <pre><code>df[2, \"species\"] #or df[2, 1]\n</code></pre> <p><pre><code>[1] \"species B\"\n</code></pre> remember, you can always use variable names instead of indexes:</p> <pre><code>row_number &lt;- 2\ncolumn_name &lt;- \"species\"\ndf[row_number, column_name]\n</code></pre> <pre><code>[1] \"species B\"\n</code></pre>"},{"location":"data_types/#operator","title":"<code>$</code> operator","text":"<p><code>$</code> operator is used to subset list or column of data frame by name. </p> <pre><code>named_list &lt;- list(number = 1, text = \"a\", boolean = TRUE, numbers = c(123,456,789))\nnamed_list$numbers # same as named_list[[\"numbers\"]] or named_list[[4]]\n</code></pre> <pre><code>[1] 123 456 789\n</code></pre> <pre><code>df &lt;- data.frame(species = c(\"species A\",\"species B\",\"species C\"), count = c(5,10,7), year = c(2020,2020,2020))\n\ndf$species # same as df[[\"species\"]] or df[[1]]\n</code></pre> <pre><code>[1] \"species A\" \"species B\" \"species C\"\n</code></pre> <p>Tip</p> <p>You can also add columns to data.frame or elements to named list with <code>[ ]</code> or <code>$</code>, simply declaring its name as its exists:</p> <p>data.frame: <pre><code>df$source &lt;- \"field_obs\"\n# or\ndf[\"source\"] &lt;- \"field_obs\"\ndf\n</code></pre></p> <p><pre><code>    species count year    source\n1 species A     5 2020 field_obs\n2 species B    10 2020 field_obs\n3 species C     7 2020 field_obs\n</code></pre> named list: <pre><code>named_list &lt;- list(number = 1, text = \"a\", boolean = TRUE)\nnamed_list$vect &lt;- c(123,456,789)\nnamed_list\n</code></pre> <pre><code>$number\n[1] 1\n\n$text\n[1] \"a\"\n\n$boolean\n[1] TRUE\n\n$vect\n[1] 123 456 789\n</code></pre></p>"},{"location":"data_types/#missing-values-na","title":"Missing values <code>NA</code>","text":"<p><code>NA</code> is simply missing value, <code>NaN</code> is 'not a number' (and its also <code>NA</code>). <code>NA</code> can be any type, but <code>NaN</code> is double. You can check if value is <code>NA</code> with <code>is.na()</code> function.</p> <p>Numeric vector <pre><code>x &lt;- c(123, 456, NA, 789, NaN)\n</code></pre></p> <p>Check which values are <code>NA</code>: <pre><code>is.na(x)\n</code></pre></p> <pre><code>[1] FALSE FALSE  TRUE FALSE  TRUE\n</code></pre> <p>Check which values are <code>NaN</code>: <pre><code>is.nan(x)\n</code></pre></p> <pre><code>[1] FALSE FALSE FALSE FALSE  TRUE\n</code></pre> <p><code>NA</code> values can cause problems in calculations</p> <pre><code>mean(x)\n</code></pre> <p><pre><code>[1] NA\n</code></pre> We can usually remove <code>NA</code> values with <code>na.rm</code> or similar argument, see help for function with <code>?</code>:</p> <pre><code>mean(x, na.rm = TRUE)\n</code></pre> <pre><code>[1] 456\n</code></pre> <p><code>NA</code> values can be also removed directly with <code>na.omit()</code> function:</p> <pre><code>na.omit(x)\n</code></pre> <pre><code>[1] 123 456 789\nattr(,\"na.action\")\n[1] 3 5\nattr(,\"class\")\n[1] \"omit\"\n</code></pre> <p>String vector (note that <code>NA</code> is not quoted in result):</p> <pre><code>x &lt;- c(\"a\", \"b\", NA, \"c\", NaN)\nx\n</code></pre> <pre><code>[1] \"a\"   \"b\"   NA    \"c\"   \"NaN\"\n</code></pre>"},{"location":"files_workflow/","title":"Reading and writing files, project workflow","text":"<p>In this section we learn how to work with simplistic project workflow, and how to read and write processed files.</p>"},{"location":"files_workflow/#project-workflow","title":"Project workflow","text":"<p>The directory where the R console is launched is called Working directory. This is important when you want to work with files.  The working directory can be confortably changed with the function <code>setwd()</code>, but its not so good practice, and its  better to make habit to work with relative paths in project directory based workflow. This ensures that the code will work without changes if you move the project direcory to another place, renaming part of path, use other IDE, use Git etc. </p> <p>While wokring with the data in R, it is good practice to:</p> <ol> <li> <p>one directory - keep all files (data, scripts, outputs) in one directory (project or workspace directory) and run R from this  directory (working directory)</p> </li> <li> <p>automate as much as possible - write scripts that  reproduce the workflow, without the need to store some workspace files (<code>.RData</code>). This includes reading data, processing, writing outputs etc. </p> </li> </ol> <p>Note</p> <p>This is not necessary for working with R, but it is good practice to avoid building bad habits. In some cases, you will need to use absolute paths, i.e. when starting R project and you have dedicated directory for some general data which are often used. But try to avoid it as much as possible, since this disables the possibility of sharing the project.</p>"},{"location":"files_workflow/#setting-project-directory","title":"Setting project directory","text":"<p>When starting, just create a directory for your project, move data files to the data directory, and create scripts in the scripts directory. Example of simple project directory structure:</p> <pre><code>project_name/\n\u251c\u2500\u2500 data/\n\u251c\u2500\u2500 scripts/\n\u251c\u2500\u2500 outputs/\n</code></pre> <ul> <li>data/ - directory for all input data (<code>.csv</code>, <code>.shp</code>, <code>.gpkg</code>,<code>.tif</code>, ...)</li> <li>scripts/ - directory for R scripts</li> <li>outputs/ - directory for output files - plots, tables, ...</li> </ul> <p>Tip</p> <p>You can create this structure in RStudio by creating a new project and than creating the directories incliding files (scripts, etc.) in the Files pane.</p>"},{"location":"files_workflow/#rstudio-setting","title":"RStudio setting","text":"<ul> <li>.RData workspace - R can save the entire workspace (all objects, variables, functions, ...) to the <code>.RData</code> file, which can be    restored. Don't use the workspace. Better practice is write your scripts in a way that they recreate the worksapce.<ul> <li>option to set: Tools -&gt; Global options -&gt; General/basic tab: Workspace - Restore .RData - uncheck; .RData on exit Never</li> </ul> </li> <li>text encoding - use UTF-8 when saving files.<ul> <li>option to set: Tools -&gt; Global options -&gt; Code/Saving tab -&gt; Default text encoding: UTF-8</li> </ul> </li> <li>Working directory -  use the Project feature, which creates a project file <code>.Rproj</code> in the project    directory. Loading <code>.Rproj</code> automatically set the working directory to the project directory.<ul> <li>no option to set, jsut keep in mind that you are working in project directory, use relative paths while    working with files and save <code>.Rproj</code> (if you use RStudio)   file in the project directory</li> <li>creating project - File -&gt; New Project...</li> <li>opening existing project - File -&gt; Open Project... or File -&gt; Recent Projects</li> <li>RStudio opens last project by default, but you can change this in Tools -&gt; Global options -&gt; General/basic    tab: Default working directory - disable Restore most recently opened project at startup</li> </ul> </li> </ul>"},{"location":"files_workflow/#first-project","title":"First project","text":"<p>In this example project we write one script that reads the data, makes some simple processing and writes the output  to new file. We will work with export from DRUSOP which is digital register of central list of nature conservation  in the Czech Republic.</p> <ol> <li>Create a new project and directory (first_project or name it as you want) - this can be done in RStudio</li> <li>Create subdirectories in data, scripts and outputs - just creating directories</li> <li>Create a new script file first_script.R in the scripts directory - just creating file</li> <li>Download the data file<ul> <li>go to the https://drusop.nature.cz/ and select Maloplo\u0161n\u00e1 zvl\u00e1\u0161t\u011b chr\u00e1n\u011bn\u00e1 \u00fazem\u00ed in  the Objekty \u00fast\u0159edn\u00edho seznamu section.</li> <li>click the Export button, - check all with Ozna\u010d/Zru\u0161 V\u0160E na str\u00e1nce, select Excel (CSV) format in Form\u00e1t,  UTF-8 encoding in K\u00f3dov\u00e1n\u00ed, and click export Exportovat. This will download the file export.csv. Move this  file to the data directory.</li> </ul> </li> </ol> <p>Aim of the project:</p> <p>Perform some basic exploration of the data, and create a csv table only with protected areas with area larger than 500 ha, declared from the 2020.</p>"},{"location":"files_workflow/#dataset","title":"Dataset","text":"<p>The dataset contain information about smaller specially protected areas in 4 categories: national nature reserves (NPR), nature reserves (PR), national natural monuments (NPP), and natural monuments (PP)</p>"},{"location":"files_workflow/#reading-data-and-general-exploration","title":"Reading data and general exploration","text":"<p>Our file is <code>.csv</code> file, which is simple data structure for storing tables in simple text file, see CSV on Wikipedia. You can open <code>.csv</code> in common spreadsheet editor such as MS Excel or Libre Oficce Calc. In R we can read it with the function <code>read.csv()</code> from <code>read.</code> family of functions. As an argument, we pass the path to the file. The path can be absolute or relative, and it can be also url pointing to the file on some server. </p> <p><pre><code>df &lt;- read.csv(\"data/export.csv\")\n</code></pre> Now we have the data stored in the <code>df</code> object, which is <code>data.frame</code> object. Now you need to check if the data are read  correctly (which is not always the case). You can show the data with calling <code>df</code> as any other object:</p> <p><pre><code>df\n</code></pre> But as you see this is not ideal. There are two functions to explore the data - <code>head()</code> and <code>str()</code> (from previous section).</p> <p><code>head()</code> returns a <code>data.frame</code> with the first 6 rows of the original data frame:</p> <pre><code>head(df)\n</code></pre> <p>Now we can se that the data is messy. Better way to explore the data is to use <code>str()</code> function, which returns the  structure of the data frame, including rows and columns count, columns data types and names, and example of first values in the columns</p> <pre><code>str(df)\n</code></pre> <p>Tip</p> <p>The <code>str()</code> and <code>head()</code> function are the most used functions for exploring the data. You can also use <code>summary()</code> function. These function are usualy executed directly in the console, but you can also use them in the script.</p> <p>Now we can see that the data are not read correctly. We have <code>2681</code> rows (observations) and only 1 column (variable). Evidently this is caused by reading data with wrong separator, because the <code>read.csv()</code> function uses comma (<code>,</code>) as  default separator, but the data are separated by semicolon (<code>;</code>).</p> <p>This and many ohter parameters can be set in the <code>read.csv()</code> function as arguments, see <code>?read.csv</code> for help.</p> <p>To set the separator, we can use the <code>sep</code> argument:</p> <pre><code>df &lt;- read.csv(\"data/export.csv\", sep = \";\")\nstr(df)\n</code></pre> <p>Strucutre of the data now looks better but still not ideal - check the column <code>Rozloha..ha</code> which have data type <code>chr</code> (character) but should be <code>num</code> (numeric). This is caused by the decimal separator, which is comma (<code>,</code>) instead of dot (<code>.</code>). This can be set in the <code>read.csv()</code> function with the <code>dec</code> argument:</p> <pre><code>df &lt;- read.csv(\"data/export.csv\", sep = \";\", dec = \",\")\nstr(df)\n</code></pre>"},{"location":"files_workflow/#exploring-and-cleaning-data","title":"Exploring and cleaning data","text":"<p>Now when we correctly read the data, we can explore them. We did some exploration with the <code>str()</code> function,  but in following exercises we will do some further exploration.</p> <p>This is not some exploration routine, we just show in this section common cases you will encounter while processing data, so you learn how to solve these basic problems.</p>"},{"location":"files_workflow/#is-there-any-protected-area-twice-in-the-data","title":"Is there any protected area twice in the data?","text":"<p>At first its good to know some nature of the data, for example if the data strictly represent single protected area in each row, e.g. if there are no duplicates.</p> <p>We can check this by many ways. We know that every monument has its unique code <code>K\u00f3d</code>, so we can check if there are any duplicates in the <code>K\u00f3d</code> column. We can do this by many ways, but we will show two simple ways:</p> <ul> <li>using the <code>duplicated()</code> and <code>sum()</code> - <code>duplicated()</code> returns logical vector of duplicated rows (vector of <code>TRUE</code> or <code>FLASE</code> values), and <code>sum()</code> counts the number of <code>TRUE</code> values:</li> </ul> <p><pre><code>dupl_kod &lt;- duplicated(df$K\u00f3d)\nsum(dupl_kod)\n# or simply\nsum(duplicated(df$K\u00f3d))\n</code></pre> - using the <code>unique()</code> and <code>length()</code> - <code>unique()</code> returns unique values in the vector, and <code>length()</code> counts the number of unique values, so if length of unique values is same as length of the original data, there are no duplicates:</p> <pre><code>uniq_kod &lt;- unique(df$K\u00f3d)\nlength(uniq_kod)\n# or simply\nlength(unique(df$K\u00f3d))\nlength(df$K\u00f3d) # length of original data\n</code></pre> <p>So now we know that each protected area is represented by single row.</p>"},{"location":"files_workflow/#dealing-with-na-what-is-the-mean-area-of-the-protected-areas","title":"Dealing with <code>NA</code> - What is the mean area of the protected areas?","text":"codesolution <pre><code>mean(df$Rozloha..ha)\n</code></pre> <p>returns <code>NA</code>, which indicates that there are some <code>NA</code> values in the data. </p> <p>Tip</p> <p>This can be further explored by the <code>is.na()</code> function, which returns logical vector of <code>TRUE</code> and <code>FALSE</code> values. This can be simply checked be <code>unique()</code> function (show unique values of vector), or summarized with <code>table()</code> function (counts the unique values of vector).</p> <pre><code>table(is.na(df$Rozloha..ha))\nunique(is.na(df$Rozloha..ha))\n</code></pre> <p>We can use the <code>na.rm</code> argument to remove the <code>NA</code> values from the calculation:</p> <pre><code>mean(df$Rozloha..ha, na.rm = TRUE)\n</code></pre>"},{"location":"files_workflow/#explore-the-na-value-of-the-rozlohaha-column","title":"Explore the <code>NA</code> value of the <code>Rozloha..ha</code> column","text":"<p>We know that we can perform some calculation ommiting the na with the <code>na.rm</code> argument, but its good to know what is the <code>NA</code> value in the data.</p> <p>We know that we can return logical vector of <code>TRUE</code> and <code>FALSE</code> values with the <code>is.na()</code> function, and further use this vector to subset the data frame, returning only the row with <code>NA</code> value in the <code>Rozloha..ha</code> column: </p> <p><pre><code>df[is.na(df$Rozloha..ha),]\n</code></pre> Which returns line <code>2681</code>, and as we know the <code>df</code> have <code>2681</code> rows (observations), so its the last row of the data.</p> <p>Its clear that the last row is not a valid observation, and in this case its kind of metadata from data provider, so it should be cleaned up from the data.</p>"},{"location":"files_workflow/#removing-the-row","title":"Removing the row","text":"<p>In this case there are many ways to remove the row. Here are some simple examples:</p> <ul> <li>simpy with the <code>[-2681]</code> notation, where <code>-</code> mens to exclude the row with index <code>2681</code>:</li> </ul> <p><pre><code>df[-2681, ]\n</code></pre> - with the subset of using <code>is.na()</code> function, but using <code>!</code> operator to negate (reverse) the logical vector, so it performs the opposite operation - get all rows where <code>Rozloha..ha</code> is not <code>NA</code>:</p> <pre><code>df[!is.na(Rozloha..ha), ]\n</code></pre> <ul> <li>with the subset of string of some column</li> </ul> <pre><code>df[df$K\u00f3d != \"COUNT:\", ]\n</code></pre> <p>Choose the one you like the most, and assign it to the <code>df</code> object:</p> <pre><code>df &lt;- df[!is.na(df$Rozloha..ha), ]\n</code></pre>"},{"location":"files_workflow/#dealing-with-dates","title":"Dealing with Dates","text":"<p>There are few columns with dates in the data, for example <code>Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed</code>. This column is the <code>character</code> data type, but if we want to work with dates, we have to convert it for further analyssis like counting the number of protected areas with certain year of declaration, etc.</p> <p>We can convert the column to the <code>Date</code> class with the <code>as.Date()</code> function. Or just retrieve the desired information (year) with the <code>substr()</code> function.</p> <p>We need to know how the dates looks like, so we list first, or first few dates:</p> <pre><code>df$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed[1:10]\nclass(df$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed[1:10])\n</code></pre> <p>So this date is formatted as <code>dd.mm.yyyy</code> - <code>day.month.year</code>, so we can use the <code>as.Date()</code> function with the <code>format</code> argument with <code>\"%d.%m.%Y\"</code> to convert the column to the <code>Date</code> class (in <code>YYYY-MM-DD</code> format):</p> <pre><code>as.Date(df$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed[1:10], format = \"%d.%m.%Y\")\nclass(as.Date(df$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed[1:10], format = \"%d.%m.%Y\"))\n</code></pre> <p>If we have task to find the newest protected area, we can use the <code>max()</code> function on the converted column:</p> <pre><code>max(df$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed) # nonsense, its character - text\nmax(as.Date(df$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed, format = \"%d.%m.%Y\"))\n</code></pre> <p>Converting column to the <code>Date</code> class is just replacing the values with the new values in <code>Date</code> class:</p> <p><pre><code>df$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed &lt;- as.Date(df$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed, format = \"%d.%m.%Y\")\nmax(df$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed)\n</code></pre> Now we can filter the data with the date, for example to get the protected areas declared after 2020:</p> <pre><code>d &lt;- as.Date(\"2020-01-01\")\ndf[df$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed &gt; d,]\n</code></pre>"},{"location":"files_workflow/#other-exploration","title":"Other exploration","text":""},{"location":"files_workflow/#get-the-protected-areas-with-area-larger-than-500-ha-and-category-npr","title":"Get the protected areas with area larger than 500 ha and category NPR","text":"<pre><code>df[df$Rozloha..ha &gt; 500,]\n</code></pre>"},{"location":"files_workflow/#get-the-protected-areas-with-area-larger-than-500-ha-and-category-npr_1","title":"Get the protected areas with area larger than 500 ha and category NPR","text":"<pre><code>df[df$Kategorie == \"NPR\",]\n</code></pre>"},{"location":"files_workflow/#what-is-the-total-area-of-the-protected-areas","title":"What is the total area of the protected areas?","text":""},{"location":"files_workflow/#which-protected-area-is-the-largest","title":"Which protected area is the largest?","text":""},{"location":"files_workflow/#which-category-has-the-largest-protected-area","title":"Which category has the largest protected area?","text":""},{"location":"files_workflow/#how-many-protected-areas-are-in-each-category","title":"How many protected areas are in each category?","text":""},{"location":"files_workflow/#writing-the-output","title":"Writing the output","text":"<p>As we cane read the <code>.csv</code> file, we can also creating/write it. We can use the <code>write.csv()</code> function from the <code>write.</code> family of functions. The <code>write.csv()</code> function writes the <code>data.frame</code> to the <code>.csv</code> file. </p> <pre><code>write.csv(df, \"outputs/processed_data.csv\", row.names = FALSE)\n# we use the row.names = FALSE to not write the row names to the file\n</code></pre> <p>If the task was: Create export of the protected areas with area larger than 500 ha and category NPR, the entire script can look like this:</p> <pre><code>df &lt;- read.csv(\"data/export.csv\", sep = \";\", dec = \",\")\n\ndf &lt;- df[!is.na(df$Rozloha..ha), ]\ndf$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed &lt;- as.Date(df$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed, format = \"%d.%m.%Y\")\n\nd &lt;- as.Date(\"2020-01-01\")\ndf &lt;- df[df$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed &gt; d,]\n\ndf &lt;- df[df$Rozloha..ha &gt; 500,]\ndf &lt;- df[df$Kategorie == \"NPR\",]\n\nwrite.csv(df, \"outputs/processed_data.csv\", row.names = FALSE)\n</code></pre> <p>or using the \"and\" operator <code>&amp;</code>:</p> <pre><code>df &lt;- read.csv(\"data/export.csv\", sep = \";\", dec = \",\")\n\ndf$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed &lt;- as.Date(df$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed, format = \"%d.%m.%Y\")\nd &lt;- as.Date(\"2020-01-01\")\ndf &lt;- df[!is.na(df$Rozloha..ha) &amp; df$Rozloha..ha &gt; 500 &amp; df$Kategorie == \"NPR\" &amp; df$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed &gt; d, ]\n\nwrite.csv(df, \"outputs/processed_data.csv\", row.names = FALSE)\n</code></pre>"},{"location":"files_workflow/#practice-exploration","title":"Practice exploration","text":"<p>Practice some exploration on the Zoraptera Occurrence Dataset (https://zenodo.org/records/14652555). The dataset contains information about the occurrence of the order Zoraptera. The link directly to dataset is \"https://raw.githubusercontent.com/kalab-oto/zoraptera-occurrence-dataset/refs/tags/1.1.0/zoraptera_occs.csv\"</p> task 1solution 1 <p>Read the data, and assign them to the <code>zoraptera</code> object</p> <pre><code>zoraptera &lt;- read.csv(\"https://raw.githubusercontent.com/kalab-oto/zoraptera-occurrence-dataset/refs/tags/1.1.0/zoraptera_occs.csv\")\n</code></pre> task 2solution 2 <p>How many observations and variables are in the data?</p> <p>There are <code>656</code> rows (observations) and <code>41</code> columns (variables)</p> task 3solutfion 3 <p>Is there <code>species</code> column in the data?</p> <p>There is no <code>species</code> column</p> task 4solutfion 4 <p>How many records are not identified to the species level?</p> <p><code>581</code></p> task 5solutfion 5 <p>What is the most common species in the data?</p> <p><code>Usazoros hubbardi</code></p> task 6solution 6 <p>What is the most common <code>country</code> in the data?</p> <p><code>United States of America</code></p> task 7solution 8 <p>How many records are from the <code>Fiji</code>?</p> <p><code>9</code></p>"},{"location":"intro/","title":"Introduction to R","text":""},{"location":"intro/#what-is-r","title":"What is R?","text":"<ul> <li>R is a programming language for statistical computing but...</li> <li>... you can use it without any knowledge of statistics - to do data manipulation, data visualization, and more (file    handling, automatization, web scraping, ...)</li> <li>it is open-source, free and multiplatform</li> <li>https://cran.r-project.org/</li> <li>R can be used in two ways: interactively in command line or the code can be saved in scripts - files    with code (<code>.R</code>, <code>.r</code>)</li> <li>the scripts can be written in any text editor, but there are specialized software to make writing and running code   easier: IDEs (Integrated Development Environment)</li> <li>the most popular IDE for R is RStudio -    https://posit.co/download/rstudio-desktop/ but see    Positron (IDE based on VS Code)</li> <li>other IDEs used for R: VS Code, Vim, Emacs, Jupyter Notebook ...</li> <li>so R \u2260 RStudio</li> </ul>"},{"location":"intro/#why-programming-for-spatial-data-handling","title":"Why programming for spatial data handling?","text":"<ul> <li>why write programs/scritps when I can already can do the same in Excel, QGIS, ArcGIS, ... ?</li> <li> <p>practically, you can do the same, but with programming you writing the \"reciepe\" how to do it, which can leads to:</p> <ul> <li>reproducibility - run the code again, share, collaborate when coding</li> <li>flexibility - do the same task with different data, change/improve parts of the workflow anytime</li> </ul> </li> </ul> <p>Example</p> <p>Imagine this GIS task: Get mean evelation for 1 km area around occurrence of specific species A. So the task will be  something like:</p> <ol> <li>read point vector data (shapefile, geopackage, ...)</li> <li>retrieve only points with specific attribute (species is <code>species A</code>)</li> <li>do 1 km buffer around the points</li> <li>read the raster data (DEM)</li> <li>extract raster values for the buffer areas, and calculate the mean</li> <li>write it to a file</li> </ol>  But than... <p>... what if you need to make same changes in workflow? Like:</p> <ul> <li>do this for all other species in the dataset ...</li> <li>... and for multiple buffer distances ...</li> <li>and for other 100 raster tiffs in the direcotry or on servers (monthly temperatures, percipitation, pressure, ...)</li> </ul> <p>You can also do this in desktop applications, but it will be time consuming and inefficient. With writing the workflow  in R, you can easily change the parameters, set multiple values run it on multiple datasets, with minimal effort  compared to manual work.</p>"},{"location":"intro/#r-syntax","title":"R syntax","text":"<ul> <li>no strinct syntax rules, and naming conventions</li> <li>many ways to do the same thing</li> <li>many packages for different tasks </li> <li>many packages for same tasks</li> <li>code styles /\"grammar\" - base R, tidyverse, data.table, </li> </ul>"},{"location":"intro/#installation-of-r","title":"Installation of R","text":"<ul> <li>Download R from https://cran.r-project.org/<ul> <li>choose your system (Windows, macOS or Linux) and follow the instruction</li> <li>for windows: choose base distribution, than click Download R-4.x.x for Windows and follow the installation     wizard</li> </ul> </li> </ul> <p>After installation, you can run R with inbuild IDE Rgui on directly in terminal. But in the course we will use  RStudio, and I recommend this to all beginners.</p>"},{"location":"intro/#rstudio","title":"Rstudio","text":"<p>RStudio is the most popular IDE and de facto standard for R programming. It is free and open-source, and you can  download it from https://rstudio.com/products/rstudio/download/.  Just download the installer for your system and follow the installation wizard. Than you can run RStudio and start coding. </p> <p>Note</p> <p>You have to have R installed before you install RStudio.</p> <p>We won't go too much into details for now, and just show the basic interface and useful settings for start. Other settings  will be covered during the course.</p>"},{"location":"intro/#interface","title":"Interface","text":"<p>The GUI consists of four main panes, which can be customized and rearranged. But for now we will focus on two of them:</p> <ul> <li>Console - here you can write and run code interactively</li> <li>Source - here you can write and save your scripts (files with code), and also send the parts of the code to the    console</li> </ul> <p>Note</p> <p>The R is always running in specific directory, which is called working directory. You can show the directory with  <code>getwd()</code>, or change the working directory with the function <code>setwd()</code>. Working directory is important when you  want to work with paths or files. You can use absuloute paths, but better practice is to use relative paths to the  working directory.</p>"},{"location":"packages/","title":"Packages","text":"<p>Until this point, we relied in the in-built R functions (Base R), but in real world you will use function and classes from R extensions called packages. </p> <p>There are thousands of packages available on official repository called CRAN, but also on other repositories like Bioconductor, or git repositories (i.e. on GitHub, GitLab, Codeberg, ...), or you can install packages directly from files.</p> <p>In the course we will use mainly these two packages:</p> <ul> <li><code>sf</code> - for vector spatial data manipulation</li> <li><code>terra</code> - mainly for raster spatial data manipulation, but can handle also for vector data</li> </ul> <p>In some lesson we will also use these packages:</p> <ul> <li><code>ggplot2</code> - for plotting</li> <li><code>geodata</code> - for downloading spatial data</li> <li><code>Rczechia</code> of <code>CzechData</code>- for Czech Republic spatial data</li> </ul> <p>Note</p> <p>We will also mention <code>sp</code>,<code>raster</code> packages. They are predecessors of <code>sf</code> and <code>terra</code> packages respectively, now deprecated, but you can still encounter them in some projects </p> <p>You can find more packages used in spatial analysis in Spatial Task View on CRAN.</p>"},{"location":"packages/#installing-packages","title":"Installing packages","text":"<p>Installation of packages is easy, and can be don from R console with function <code>install.packages()</code> or with dedicated button in  GUI which runs this function fro you. </p> <p>Installation of <code>sf</code> package:</p> <pre><code>install.packages(\"sf\")\n</code></pre>"},{"location":"packages/#using-packages","title":"Using packages","text":"<p>Once installed, package can be loaded in any session using <code>library()</code> function. </p> <p>Loading <code>sf</code> package:</p> <pre><code>library(sf)\n</code></pre> <p>When writing scripts, it is good practice to load all packages at the beginning of the script.</p> <p>Info</p> <p>Sometimes you can also see use of <code>require()</code> function, which is similar to <code>library()</code>, but it returns <code>TRUE</code> or <code>FALSE</code> if the package is loaded or not. And also use of <code>::</code> operator, which is used to call functions from package without loading it, like <code>sf::st_read()</code> for using <code>st_read()</code> function from <code>sf</code> package without loading it.</p>"},{"location":"raster_intro/","title":"Raster data","text":"<p>As with vector data, raster data can be handled with various packages. The most common package is the <code>terra</code> package, successor of the deprecated <code>raster</code> package. <code>terra</code> package is also capable process vector data, but it is not as complex as <code>sf</code> package in this way. </p> <p>Note</p> <p><code>terra</code> objects are spcific objects (S4), data are stoed in matrix/array not in data.frame. It have hidden structure and its not stored in lists like <code>sf</code> objects. To access the metadata you have to use specific functions.</p> <pre><code># install.packages(\"terra\")\nlibrary(terra)\n</code></pre>"},{"location":"raster_intro/#reading-raster-data-spatraster","title":"Reading raster data - <code>SpatRaster</code>","text":"<p><pre><code>dem &lt;- rast(\"data/eudem.tif\")\ndem\n\ncrs(dem)\next(dem)\n</code></pre> plot the raster data <pre><code>plot(dem)\n</code></pre> plot the histogram of the raster data <pre><code>hist(dem)\n</code></pre> get more bins</p> <p><pre><code>hist(dem, breaks = 100)\n</code></pre> Class <code>SpatRaster</code> can handle multiple layers (bands) of raster data. These can be accessed by <code>[[</code> operator as in lists. Layers can be stacked together simply with <code>c()</code> function, but layers have to have the same extent, resolution and crs. </p> <p><pre><code>dem2 &lt;- c(dem, dem)\ndem2\ndem2[[1]]\n</code></pre> Layers can be named, and accessed by name. </p> <p><pre><code>names(dem2) &lt;- c(\"dem1\", \"dem2\")\ndem2[[\"dem1\"]]\n</code></pre> Filtering layers can be done by <code>[[</code> operator with index including negative idenxing.</p> <p>drop the first layer: <pre><code>dem3 &lt;- dem2[[-1]]\n</code></pre> get the first layer: <pre><code>dem3 &lt;- dem2[[1]]\n</code></pre></p>"},{"location":"raster_intro/#summary-statistics","title":"Summary statistics","text":"<p>How to get mean, min, max, sum, etc. of the raster data?</p> <pre><code>mean(dem)\nmax(dem)\n</code></pre> <p>This seems not works as expected. That is because theese functions calculates tha statistics across all layers, eg. maximum value of all layers at each certain pixel position.</p> <p>To get quick statistics for each layer, you can use <code>summary</code> function. <pre><code>summary(dem)\n</code></pre></p> <p>or work with the raw values of the raster data, but take care of the <code>NA</code> values.</p> <pre><code>mean(values(dem), na.rm = TRUE)\n</code></pre>"},{"location":"raster_intro/#terrain-analysis","title":"Terrain analysis","text":"<p>function <code>terrain</code> can be used to calculate various terrain attributes from the DEM. See <code>?terrain</code> for more details.</p> <pre><code>slope &lt;- terrain(dem, \"slope\")\naspect &lt;- terrain(dem, \"aspect\")\n</code></pre> <p>stack the layers together <pre><code>dem &lt;- c(dem, slope, aspect)\n</code></pre> plot entire object <pre><code>plot(dem)\n</code></pre></p> <p>or all histograms of the slope layer <pre><code>hist(dem)\n</code></pre></p> trysolution <p>plot only the slope layer from <code>dem</code> object</p> <pre><code>plot(dem[[2]])\n# or\nplot(dem[[\"slope\"]])\n</code></pre>"},{"location":"raster_intro/#reclassification","title":"Reclassification","text":""},{"location":"raster_intro/#logical-reclassification","title":"logical reclassification","text":"<p>simply use logical operators to create new raster object with values <code>TRUE</code> and <code>FALSE</code> (1 and 0)</p> <p><pre><code>reclassified_dem &lt;- dem[[1]]  &gt; 1000\nplot(reclassified_dem)\n</code></pre> multiple conditions can be combined with logical operators <pre><code>reclassified_dem &lt;- dem[[1]] &gt; 500 &amp; dem[[1]] &lt; 550\n</code></pre></p>"},{"location":"raster_intro/#replacing-values","title":"replacing values","text":"<p>use of subsetting and logical operators can be used to replace values in the raster data. </p> <pre><code>reclassified_dem &lt;- dem[[1]]\nreclassified_dem[reclassified_dem &gt; 500] &lt;- NA\nplot(reclassified_dem)\n</code></pre> <p>Tip</p> <p>functions <code>replace</code> or <code>ifelse</code> works similar way, but can be used also for more complex operations</p> <pre><code>reclassified_dem &lt;- replace(dem[[1]], dem[[1]] &gt; 1000, 1)\nplot(reclassified_dem)\n</code></pre>"},{"location":"raster_intro/#value-reclassification","title":"value reclassification","text":"<p>Standard way to reclassify is use of <code>classify</code> function, which reclassify the raster data with reclassification matrix. The matrix has to have 3 columns, first two are the range of values and the third is the value to replace the values in the range.  </p> <p><pre><code>reclass_matrix &lt;- matrix(c(0, 500, 1,    \n                           500, 1000, 2,  \n                           1000, Inf, 3),  \n                         ncol = 3, byrow = TRUE)\n\nreclass_matrix\n</code></pre> <pre><code>reclassified_dem &lt;- classify(dem[[1]], reclass_matrix)\n</code></pre> plot the reclassified raster <pre><code>plot(reclassified_dem)\n</code></pre></p>"},{"location":"raster_intro/#map-algebra","title":"Map algebra","text":"<p>Map algebra is a way to perform operations on raster data. It is similar to vector data, but the operations are performed on the pixel values. </p> <pre><code>dem2 &lt;- dem[[1]] * 2\nplot(dem2)\n</code></pre> <pre><code>sum(dem)\n</code></pre> <p>Tip</p> <p>map algebra is commonmly used for multispectral data, eg. to calculate vegetation indices NDVI, NDWI, etc. </p>"},{"location":"raster_intro/#exercise","title":"exercise","text":"<p>Find the suitable areas for vineyards, these areas are on southern slopes (aspect between 135 and 225 degrees) with slope between 5 and 15 degrees, and elevation between 200 and 500 meters.  </p> <pre><code>dem &lt;- rast(\"/home/ok/git/orthoptera-atlas/processed_data/eudem.tif\")\nslope &lt;- terrain(dem, \"slope\")\naspect &lt;- terrain(dem, \"aspect\")\n</code></pre> <p><pre><code># Sklon mezi 5-30% (3\u201316 stup\u0148\u016f)\nsuitable_aspect &lt;- (aspect &gt;= 135) &amp; (aspect &lt;= 225)\nsuitable_slope &lt;- (slope &gt; 4) &amp; (slope &lt; 16)\nsuitable_elevation &lt;- (dem &gt;= 200) &amp; (dem &lt;= 500)\n\nsuitable_area &lt;- suitable_aspect &amp; suitable_slope &amp;  suitable_elevation\n</code></pre> If you want to keep all layers in the object, you can stack them together. </p> <p><pre><code>suitable_area &lt;- c(suitable_aspect, suitable_slope,suitable_elevation)\nplot(suitable_area)\n</code></pre> <pre><code>min(suitable_area)\nplot(min(suitable_area))\n</code></pre> get the area of the suitable areas</p> <pre><code>sum(suitable_area)\nplot(sum(suitable_area))\n</code></pre>"},{"location":"raster_intro/#writing-raster-data","title":"writing raster data","text":"<pre><code>writeRaster(suitable_area, \"outputs/suitable_area.tif\", overwrite = TRUE)\n</code></pre>"},{"location":"raster_operations/","title":"Raster data","text":""},{"location":"raster_operations/#general-r-functions","title":"General R functions","text":""},{"location":"raster_operations/#download-data","title":"Download data","text":"<p>You can download data directliy in R using <code>download.file()</code> function. In this example we will download the CHELSA climate - BIO1 1981-2010, and predicted BIO1 2071-2100 for GFDL-ESM4 model and SSP126 scenario. Check <code>?download.file</code> for arguments and options.  </p> <pre><code>download.file(\"https://os.zhdk.cloud.switch.ch/chelsav2/GLOBAL/climatologies/1981-2010/bio/CHELSA_bio1_1981-2010_V.2.1.tif\", \"data/CHELSA_bio1_1981-2010_V.2.1.tif\")\n\ndownload.file(\"https://os.zhdk.cloud.switch.ch/chelsav2/GLOBAL/climatologies/2071-2100/GFDL-ESM4/ssp126/bio/CHELSA_bio1_2071-2100_gfdl-esm4_ssp126_V.2.1.tif\", \"data/CHELSA_bio1_2071-2100_gfdl-esm4_ssp126_V.2.1.tif\")\n</code></pre>"},{"location":"raster_operations/#listing-files","title":"Listing files","text":"<p>You can list files in any directory using <code>list.files()</code> function. With argument <code>pattern</code> you can filter the files by matching string - regular expression (regex), for example part of the name or file extension.</p> <p><pre><code>list.files()\n</code></pre> list all files in the current directory recursively</p> <pre><code>list.files(recursive = TRUE)\n</code></pre> <p>or list all files in subdirectory <code>data</code>:</p> <pre><code>list.files(\"data\")\n</code></pre> <p>get the relative path of the files :</p> <pre><code>list.files(\"data\", full.names = TRUE)\n</code></pre> <p>use <code>pattern</code> to filter the files with regex <pre><code>list.files(recursive = TRUE, pattern = \"bio\")\n</code></pre></p>"},{"location":"raster_operations/#raster-manipulation","title":"Raster manipulation","text":"<p>Task:  1. Prepare raster stack of bioclimatic CHELSA data and elevation data. The resolution of the raster stack will be 30seconds (~1km) - resolution of the CHELSA data. 2. Mask the raster stack with the DEM data. 3. Create raster of distances to the nearest 1000m elevation. 4. Save the raster stack to separate files.</p> <pre><code>library(terra)\n</code></pre> <p>read all raster files in the directory <code>data</code>:</p> <pre><code>raster_files &lt;- list.files(\"data\", pattern = \".tif$\", full.names = TRUE)\n</code></pre> <p>Note</p> <p>Notice that we used <code>pattern = \".tif$\"</code> to filter only the files with <code>.tif</code> extension. The <code>$</code> means that the string should end with <code>.tif</code>.</p> <pre><code>r &lt;- rast(raster_files)\n</code></pre> <p>Info</p> <p>Function <code>rast()</code> can read also files directly from url string.</p> <pre><code>urls &lt;- c(\n    \"https://os.zhdk.cloud.switch.ch/chelsav2/GLOBAL/climatologies/1981-2010/bio/CHELSA_bio1_1981-2010_V.2.1.tif\",\n    \"https://os.zhdk.cloud.switch.ch/chelsav2/GLOBAL/climatologies/2071-2100/GFDL-ESM4/ssp126/bio/CHELSA_bio1_2071-2100_gfdl-esm4_ssp126_V.2.1.tif\"\n    )\nr &lt;- rast(urls)\nr\n</code></pre> <p>If we want to read all raster in stack, all rasters have to have the same extent, resolution and projection. We have to preprocess the data before.</p> <p>try to read only bio1 files and dem separately</p> <pre><code>r_bio &lt;- rast(list.files(\"data\", pattern = \"bio\", full.names = TRUE))\n\nr_dem &lt;- rast(\"data/eu_dem.tif\")\n</code></pre>"},{"location":"raster_operations/#get-the-same-extent","title":"get the same extent","text":"<p>For clipping raster object to specific extent use <code>crop()</code> function. It can crop the raster with extent object, or other raster object (retrieve the extent from the other raster).</p> <p><pre><code>r_bio_cz &lt;- crop(r_bio, r_dem)\n</code></pre> Extntes do not overlap, we need to reproject the raster to the same projection.</p> <pre><code>r_dem_cz &lt;- project(r_dem, crs(r_bio))\nr_bio_cz &lt;- crop(r_bio, r_dem_cz)\n</code></pre>"},{"location":"raster_operations/#resample-to-the-same-resolution","title":"resample to the same resolution","text":"<p>see <code>?resample</code> for more options, particularly <code>method</code> argument. In our case we will use some sumary method</p> <pre><code>r_dem_cz &lt;- resample(r_dem_cz,r_bio_cz, method = \"average\")\n</code></pre>"},{"location":"raster_operations/#stack-the-rasters","title":"stack the rasters","text":"<pre><code>r_stack &lt;- c(r_bio_cz, r_dem_cz)\n</code></pre>"},{"location":"raster_operations/#masking","title":"masking","text":"<p>mask the raster stack with the DEM</p> <p><pre><code>masked_z &lt;- mask(r_stack, r_dem_cz)\nplot(masked_z)\n</code></pre> or mask all raster in stack with any NA in any raster</p> <pre><code>masked_z &lt;- mask(r_stack, anyNA(r_stack))   \n</code></pre>"},{"location":"raster_operations/#distance-to-the-nearest-1000m-elevation","title":"distance to the nearest 1000m elevation","text":"<p><code>distance()</code> function calculates the distance to the nearest non-NA cell in the raster. So we need to rewrite all values less then 1000 to NA. </p> <pre><code>dem_1000 &lt;- r_dem_cz\ndem_1000[dem_1000 &lt; 1000] &lt;- NA\nplot(dem_1000)\n</code></pre> <p><pre><code>dist_1000 &lt;- distance(dem_1000)\nplot(dist_1000)\n</code></pre> mask the distance raster with the DEM and add it to the stack</p> <pre><code>dist_1000 &lt;- mask(dist_1000, r_dem_cz)\nmasked_z &lt;- c(masked_z, dist_1000)\nplot(masked_z)\n</code></pre>"},{"location":"raster_operations/#other-exercises","title":"Other exercises","text":"<ul> <li>compare between 1981-2010 and 2071-2100, where the mean temperature is greater than 9  in the Czech Republic</li> </ul> <pre><code>r9 &lt;- c(r_bio_cz[[1]] &gt; 9, r_bio_cz[[2]] &gt; 9)\n</code></pre> <p>Advanced</p> <p>write a function that will plot the difference of these rasters with given temperature threshold.</p> <ul> <li>check how the mean temperature changes between 1981-2010 and 2071-2100 in the Czech Republic</li> </ul> <pre><code>d &lt;- r_bio_cz[[2]] - r_bio_cz[[1]]\nd\nplot(d)\n</code></pre> <p>check how mean temperature changes between 1981-2010 and 2071-2100 globally</p> <pre><code>d &lt;- r_bio[[2]] - r_bio[[1]]\nplot(d)\n</code></pre>"},{"location":"sources/","title":"Sources","text":"<p>https://cran.r-project.org/doc/manuals/r-release/R-lang.html https://ds-pl-r-book.netlify.app/</p>"},{"location":"sources/#project-workflow","title":"project workflow","text":"<ul> <li>https://rstats.wtf/projects</li> <li>https://r4ds.had.co.nz/workflow-projects.html</li> </ul>"},{"location":"sources/#packages","title":"Packages","text":"<ul> <li>https://cran.r-project.org/web/views/Spatial.html</li> </ul>"},{"location":"vector_intro/","title":"Vector data","text":"<p>In R we can work with vector data using many packages, but the most popular and widely used is <code>sf</code> package, and we will use it in following lessons. Other packages used for spatial vector data processing are <code>stars</code> and <code>terra</code>, and discontinued <code>sp</code> and <code>raster</code> packages. Each from this packages has its own data classes, but they can be easily converted between each other, which can be useful, since some other packages may be dependent on data classes from specific package.</p>"},{"location":"vector_intro/#exercise","title":"Exercise","text":"<p>In this exercise we will work with National Parks and Protected Landscape Areas and aditionall informations (similar to previous lesson). We will read the data, explore it and create some plots.</p>"},{"location":"vector_intro/#data","title":"Data","text":"<ul> <li> <p>shapefile with National Parks and Protected Landscape Areas - download the data form here and extract it to <code>data/vzchu</code> directory.</p> </li> <li> <p>table with additional informations - similarly to previous lesson, get the <code>csv</code> table from https://drusop.nature.cz/, but this time with Velkoplo\u0161n\u00e1 zvl\u00e1\u0161t\u011b chr\u00e1n\u011bn\u00e1 \u00fazem\u00ed - National Parks and Protected Landscape Areas. Save the table to <code>data/</code> directory. </p> </li> </ul>"},{"location":"vector_intro/#reading-data-and-general-exploration","title":"Reading data and general exploration","text":"<p>Load <code>sf</code> package (if not installed, install it with <code>install.packages(\"sf\")</code> in console). So this line should be in the beginning of your script.</p> <pre><code>library(sf)\n</code></pre> <p>Read the data</p> <pre><code>vzchu &lt;- st_read(\"data/vzchu/vzchu.shp\")\n</code></pre> <p><code>read_sf</code></p> <p>there is also function <code>read_sf</code> - which is only alias for <code>st_read</code> with different default arguments. For more info see <code>?st_read</code> or <code>?read_sf</code> (similar applies for <code>write_sf</code> and <code>st_write</code>). The main noticable difference is that <code>read_sf</code> reads data as <code>sf-tibble</code> and <code>st_read</code> as <code>sf-data.frame</code>. </p> <p><code>st_layers</code></p> <p>If you work with files that can store multiple layers (like <code>geopackage</code>), you have to specify which layer to read by adding <code>layer</code> argument. To see available layers in file use <code>st_layers</code> function.</p> <p>Check the structure of the data</p> <pre><code>vzchu\n</code></pre> <pre><code>str(vzchu)\n</code></pre> <pre><code>summary(vzchu)\n</code></pre> <p><pre><code>class(vzchu)\n</code></pre> <pre><code>head(vzchu)\n</code></pre> <pre><code>names(vzchu)\n</code></pre></p> <p>You can see that the data is stored as <code>sf</code> object, which is <code>data.frame</code> with additional attributes. The <code>geometry</code> column contains the geometries of the features. </p> <p>So we can hadnle the data as <code>data.frame</code> and use many functionality we know from working with <code>data.frame</code>.</p> <p>for xample:</p> <p>get vector of unique values in column <code>KAT</code></p> <pre><code>unique(vzchu$KAT)\n</code></pre> <p>subsetting the columns to get only <code>KAT</code> and <code>NAZEV</code> columns</p> <pre><code>vzchu[,c(\"KAT\", \"NAZEV\")]\n</code></pre> <p>subsetting the rows to get only National Parks</p> <pre><code>vzchu[vzchu$KAT == \"NP\",]\n</code></pre> <p>Note</p> <p>You can drop the geometries and get plain <code>data.frame</code> without geometries and vice versa.</p> <p>drop geometries</p> <pre><code>vzchu_df &lt;- as.data.frame(vzchu)\n# or\nvzchu_df &lt;- st_drop_geometry(vzchu)\n</code></pre> <p>drop data.frame</p> <pre><code>vzchu_sfc &lt;- vzchu$geometry\n</code></pre>"},{"location":"vector_intro/#plotting","title":"Plotting","text":"<p>In this point we learn how to show simple plots of the data (spatial and non-spatial). We will use built-in <code>plot</code> function, which is able to plot <code>sf</code> objects, and try other  types of plots for data <code>barplot</code> and <code>hist</code> (histogram).</p> <p>Basic built-in plot functions are good for quick visualization or for simple plots, but later in the course we dedicate a whole lesson to more advanced plotting with <code>ggplot2</code> package and other packages for visualizations spatial data.</p> <p>plot two numeric columns</p> <pre><code>plot(vzchu$SHAPE_AREA, vzchu$SHAPE_LEN)\n</code></pre> <p>advanced</p> <p>regression line (linear model fit <code>lm</code>) can be easily added to the plot using <code>abline</code> function</p> <pre><code>area_len_lm &lt;- lm(vzchu$SHAPE_LEN ~ vzchu$SHAPE_AREA)\n\nplot(vzchu$SHAPE_AREA, vzchu$SHAPE_LEN)\nabline(area_len_lm)\n</code></pre> <p>histogram of <code>SHAPE_AREA</code> column</p> <pre><code>hist(vzchu$SHAPE_AREA)\n</code></pre> <p>simple barplot of categories in <code>KAT</code> column. There is need to count the values first with <code>table</code> function.</p> <pre><code>barplot(table(vzchu$KAT))\n</code></pre>"},{"location":"vector_intro/#plotting-sf-objects","title":"Plotting <code>sf</code> objects","text":"<p>You can use just <code>plot</code> with <code>sf</code> object, but this will plot all columns in the data (see <code>?plot.sf</code>).</p> <pre><code>plot(vzchu)\n</code></pre> <p>If you want to plot only specific column, you can use <code>plot</code> with subset using <code>[]</code> and name of single column. If you want to plot only geometries, you can use <code>plot</code> with <code>geometry</code> column.</p> <pre><code>plot(vzchu[\"KAT\"])\n</code></pre> <pre><code>plot(vzchu[\"geometry\"])\n#or\nplot(vzchu$geometry)\n#or\nplot(st_geometry(vzchu))\n</code></pre> <p>Some examples of use of subsetting for plotting data (same as with <code>data.frame</code>)</p> <p><pre><code>vzchu[vzchu$NAZEV == \"\u0160umava\",\"KAT\"]\nplot(vzchu[vzchu$NAZEV == \"\u0160umava\",\"KAT\"])\n</code></pre> <pre><code>plot(vzchu[vzchu$NAZEV == \"Beskydy\",\"geometry\"])\n</code></pre></p> <pre><code>plot(vzchu[vzchu$NAZEV == \"Labsk\u00e9 p\u00edskovce\",\"geometry\"])\n</code></pre> <p>Do you remeber the difference of <code>[]</code> and <code>$</code> operators?</p> <p><code>[]</code> - keeping classes, with <code>list</code> this returns <code>list</code>, with <code>data.frame</code> returns the <code>data.frame</code>, and now with <code>sf</code> object - returns <code>sf</code> object</p> <p><pre><code>vzchu[\"SHAPE_AREA\"]\nclass(vzchu[\"SHAPE_AREA\"])\n</code></pre> thus plot use <code>sf</code> object</p> <pre><code>plot(vzchu[\"SHAPE_AREA\"])\n</code></pre> <p><code>$</code> - subset which always returns the data as <code>numeric</code> vector</p> <p><pre><code>vzchu$SHAPE_AREA\nclass(vzchu[\"SHAPE_AREA\"])\n</code></pre> plot use <code>numeric</code> vector</p> <pre><code>plot(vzchu$SHAPE_AREA)\n</code></pre> <p>but! you can use <code>$</code> with <code>sf</code> object to get spatial data (<code>sfc</code> class) with the <code>geometry</code> column, since it is special <code>sfc</code> class column (see <code>str(vzchu)</code> above)</p> <p><pre><code>vzchu$geometry\nclass(vzchu$geometry)\n</code></pre> thus plotting:</p> <p><pre><code>plot(vzchu[\"geometry\"])\nplot(vzchu$geometry) # same as `plot(st_geometry(vzchu))`\n</code></pre> looks the same, but the first one is <code>sf</code> object and the second one is <code>sfc</code> object</p>"},{"location":"vector_intro/#spatial-proeprties","title":"Spatial proeprties","text":"<p>Now we will explore some spatial properties of the data.</p>"},{"location":"vector_intro/#geometry-type","title":"Geometry type","text":"<pre><code>st_geometry_type(vzchu)\n</code></pre> <p>geometry type can be converted with <code>st_cast</code> function. For example whe have <code>MULTIPOLYGON</code> (multi-part features) and we want to convert it to <code>POLYGON</code> (single-part features).</p> <pre><code>st_cast(vzchu, \"POLYGON\")\n</code></pre> <p>Note</p> <p><code>st_cast</code> can be useful if you have mixed geometry types, typically multi-part features with single-part features., then you can convert all of them to multi-part features.</p>"},{"location":"vector_intro/#bounding-box","title":"bounding box","text":"<p>Bounding box is the rectangle that encloses all the geometries in the data.</p> <pre><code>st_bbox(vzchu)\nclass(st_bbox(vzchu))\n</code></pre>"},{"location":"vector_intro/#crs-coordinate-reference-system","title":"CRS - coordinate reference system","text":"<p>See the definition of the coordinate reference system (CRS) </p> <pre><code>st_crs(vzchu)\nclass(st_crs(vzchu))\n</code></pre> <p>You can transform <code>sf</code> data to other CRS with <code>st_transform</code> function. For example we can change the CRS to WGS84 (EPSG:4326)</p> <p><pre><code>st_transform(vzchu, 4326)\n</code></pre> notice the transformed geometry column</p>"},{"location":"vector_intro/#basic-spatial-calculations","title":"Basic spatial calculations","text":"<p>Here we will calculate the area and the perimeter of the features.</p> <p><code>st_area</code> - calculate the area</p> <pre><code>st_area(vzchu)\n</code></pre> <p><code>st_periemeter</code> - calculate the perimeter</p> <pre><code>st_perimeter(vzchu)\n</code></pre> <p>add the area and perimeter to the data</p> <pre><code>vzchu$area &lt;- st_area(vzchu)\nvzchu$perimeter &lt;- st_perimeter(vzchu)\nvzchu$shape &lt;- st_perimeter(vzchu)/st_area(vzchu)\n</code></pre>"},{"location":"vector_intro/#joining-attribute-data-dataframe","title":"Joining attribute data (<code>data.frame</code>)","text":"<p>Now we will join the additional informations from the table to the <code>sf</code> object. We will use <code>merge</code> function, which is used for merging data frames. In this example we will join the information about the date of the first declaration of the National Park or Protected Landscape Area, and minimum elevation.</p> <pre><code>df &lt;- read.csv(\"data/export.csv\")\n</code></pre> <p>Since this is similar data as last lesson, we can see similar problems. We resolve this using the part of the code from last lesson.</p> <pre><code>df &lt;- read.csv(\"data/export.csv\", sep = \";\", dec = \",\")\n\ndf &lt;- df[!is.na(df$Rozloha..ha), ]\ndf$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed &lt;- as.Date(df$Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed, format = \"%d.%m.%Y\")\n</code></pre> <p>Before join, we have to check the column names  <pre><code>str(df)\nstr(vzchu)\n</code></pre></p> <p>filter out desired columns <pre><code>df &lt;- df[,c(\"K\u00f3d\", \"Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed\", \"Nadmo\u0159sk\u00e1.v\u00fd\u0161ka.min.\")]\n</code></pre></p> <pre><code>vzchu &lt;- merge(vzchu, df, by.x = \"KOD\", by.y = \"K\u00f3d\")\n</code></pre> <pre><code>vzchu\n</code></pre> <p>plot the results</p> <pre><code>plot(vzchu[\"Datum.prvn\u00edho.vyhl\u00e1\u0161en\u00ed\"])\n</code></pre> <pre><code>plot(vzchu[\"Nadmo\u0159sk\u00e1.v\u00fd\u0161ka.min.\"])\n</code></pre>"},{"location":"vector_intro/#writing-data","title":"Writing data","text":""},{"location":"vector_operations/","title":"Vector geometry operations and analysis","text":"<p>data for this lesson</p> <pre><code>library(sf)\nclc &lt;- st_read(\"data/CLC18_CZ.shp\")\nvzchu &lt;- st_read(\"data/vzchu.shp\")\nmantis &lt;- read.csv(\"data/observations-537954.csv\")\n</code></pre>"},{"location":"vector_operations/#creating-sf-objects-from-coordinate-data-dataframe","title":"Creating <code>sf</code> objects from coordinate data (<code>data.frame</code>)","text":"<pre><code>mantis_sf &lt;- st_as_sf(mantis, coords = c(\"longitude\", \"latitude\"), crs = 4326)\nmantis_sf &lt;- st_transform(mantis_sf, 5514)\nplot(mantis_sf$geometry)\n</code></pre>"},{"location":"vector_operations/#spatial-join","title":"Spatial join","text":"<p>How many mantis observations are in NP and PLA?</p> <pre><code>st_join(mantis_sf, vzchu)\n#or\nst_intersection(mantis_sf, vzchu)\n</code></pre> <p>In which land cover class are the mantis observations most often?</p> <pre><code>st_join(mantis_sf, clc)\n</code></pre> <pre><code>st_crs(clc) &lt;- st_crs(mantis_sf) #or st_transform(clc, st_crs(vzchu))\nmantis_clc &lt;- st_join(mantis_sf, clc)\n</code></pre> <pre><code>mantis_clc$CODE_18\ntable(mantis_clc$CODE_18) \nsort(table(mantis_clc$CODE_18),decreasing = T)\n</code></pre>"},{"location":"vector_operations/#spatial-operations","title":"Spatial operations","text":"<p>We will use the <code>Beskydy</code> region as an example.</p> <pre><code>beskydy &lt;- vzchu[vzchu$NAZEV == \"Beskydy\", \"geometry\"]\nplot(beskydy)\n</code></pre>"},{"location":"vector_operations/#subsetting","title":"subsetting","text":"<p>subsetting points - How many mantis observations are in PLA Beskydy?</p> <p><pre><code>mantis_beskydy &lt;- mantis_sf[beskydy,]\nmantis_beskydy\nplot(beskydy$geometry)\nplot(mantis_beskydy$geometry, add = TRUE)\n</code></pre> or using <code>st_intersection</code> function</p> <pre><code>mantis_beskydy &lt;- st_intersection(mantis_sf, beskydy)\nplot(beskydy$geometry)\nplot(mantis_beskydy$geometry, add = TRUE)\n</code></pre> <p>subsetting polygons</p> <pre><code>clc_beskydy &lt;- clc[beskydy,]\nplot(clc_beskydy$geometry)\nplot(beskydy$geometry, border = \"red\", add = T, lwd = 2)\n</code></pre>"},{"location":"vector_operations/#clip","title":"clip","text":"<p>What is the most common land cover class in Beskydy?</p> <pre><code>clc_beskydy &lt;- st_intersection(beskydy, clc)\nplot(clc_beskydy$geometry)\nplot(beskydy$geometry, border = \"red\", add = T, lwd = 2)\ntable(clc_beskydy$CODE_18)\nsort(table(clc_beskydy$CODE_18), decreasing = T)\n</code></pre> <p>What is the area of each land cover class in Beskydy?</p> <ol> <li>sum the <code>data.frame</code> area column with <code>aggregate</code> function</li> </ol> <pre><code>aggregate(x = clc_beskydy$Area_Ha, by = list(clc_beskydy$CODE_18), FUN = sum)\n</code></pre> <ol> <li>aggregate the <code>sf</code> object area column with <code>aggregate</code> function</li> </ol> <pre><code>clc_beskydy_ag &lt;- aggregate(clc_beskydy, list(clc_beskydy$CODE_18), sum)\n</code></pre>"},{"location":"vector_operations/#buffer","title":"buffer","text":"<p>What is the area of each land cover class in 1km buffer around the mantis observations?</p> <pre><code>buffer_mantis &lt;- st_buffer(mantis_beskydy, 1000)\nplot(buffer_mantis$geometry)\n</code></pre> <p><pre><code>clc_buffer_mantis &lt;- st_intersection(clc,buffer_mantis)\n</code></pre> overlapping polygons <pre><code>overlapping_polygons &lt;- st_overlaps(clc_buffer_mantis)\noverlapping_polygons &lt;- clc_buffer_mantis[unlist(overlapping_polygons),]\nplot(overlapping_polygons[\"CODE_18\"])\n</code></pre> use <code>st_union</code> to merge overlapping buffer polygons (similar to <code>dissolve</code> in desktop GIS)</p> <pre><code>clc_buffer_mantis &lt;- st_union(clc_buffer_mantis)\nclc_buffer_mantis &lt;- st_intersection(clc,buffer_mantis)\n</code></pre> <pre><code>aggregate(x = st_area(clc_buffer_mantis), by = list(clc_buffer_mantis$CODE_18), FUN = sum)\n</code></pre>"},{"location":"vector_operations/#centroid","title":"centroid","text":"<pre><code>centroid_vzchu &lt;- st_centroid(vzchu)\nplot(vzchu$geometry, col = \"grey\")\nplot(centroid_vzchu$geometry, col = \"red\", add = TRUE)\n</code></pre>"},{"location":"vector_operations/#convex-hull-mcp-home-range","title":"convex hull (mcp home range)","text":"<pre><code>hull_mantis &lt;- st_convex_hull(st_union(mantis_beskydy))\nplot(hull_mantis, col = \"grey\")\nplot(mantis_beskydy$geometry, col = \"red\", add = TRUE)\n</code></pre>"},{"location":"vector_operations/#distance","title":"distance","text":"<p>distance matrix <pre><code>mantis_distances &lt;- st_distance(mantis_sf, vzchu)\nhead(mantis_distances)\n</code></pre></p>"},{"location":"vector_operations/#compute-the-most-distant-mantis-observation-to-any-protected-area","title":"Compute the most distant mantis observation to any protected area","text":"<pre><code>mantis_distances &lt;- st_distance(mantis_sf, vzchu)\nmax(mantis_distances)\nhist(mantis_sf$max_distance)\n</code></pre>"},{"location":"vector_operations/#distance-compute-the-nearest-distance-from-each-mantis-observation-to-the-nearest-protected-area","title":"distance: Compute the nearest distance from each mantis observation to the nearest protected area","text":"<p>apply family of functions (apply, lapply)</p> <p>Info</p> <p><code>apply</code> function applies a function to the rows or columns of a matrix or array.  <code>lapply</code> function applies a function to each element of a list or vector.</p> <p><pre><code>m &lt;- matrix(1:9, nrow = 3)\nm\napply(m, 1, sum)\napply(m, 2, sum)\n</code></pre> <pre><code>l &lt;- list(10:50,6:10,45:100)\nl\nlapply(l, mean)\n</code></pre></p> <pre><code>mantis_distances &lt;- st_distance(mantis_sf, vzchu)\nmantis_sf$min_distance &lt;- apply(mantis_distances, 1, min)\nhist(mantis_sf$min_distance, breaks = 20, main = \"Distance to Nearest Protected Area\", xlab = \"Distance (m)\")\n</code></pre>"},{"location":"vector_operations/#exercise-append-land-cover-areas-to-mantis-data","title":"Exercise: Append Land Cover Areas to Mantis Data","text":"<pre><code>mantis_beskydy &lt;- mantis_sf[beskydy,]\nclc_beskydy &lt;- clc[beskydy,]\n\nbuffer_mantis &lt;- st_buffer(mantis_beskydy, 1000)\n\nclc_buffer_mantis &lt;- st_intersection(clc,buffer_mantis)\n\n\nclc_buffer_mantis$area &lt;- st_area(clc_buffer_mantis)\n\n# Aggregate areas by mantis observation and land cover class\nmantis_clc_areas &lt;- aggregate(clc_buffer_mantis$area,\n                              by = list(mantis_id = clc_buffer_mantis$id,\n                                        CODE_18 = clc_buffer_mantis$CODE_18),\n                              FUN = sum)\n\n# Reshape to wide format and merge with mantis dataset\nmantis_clc_wide &lt;- reshape(mantis_clc_areas, idvar = \"mantis_id\", timevar = \"CODE_18\", direction = \"wide\")\n\nmantis_sf &lt;- merge(mantis_sf, mantis_clc_wide, by.x = \"id\", by.y = \"mantis_id\", all.x = TRUE)\n</code></pre>"},{"location":"vector_operations/#summary","title":"Summary","text":""},{"location":"vector_operations/#new-functions","title":"New functions","text":""},{"location":"vector_operations/#base-r","title":"Base R","text":"<ul> <li><code>merge()</code></li> <li><code>apply()</code></li> <li><code>reshape()</code></li> </ul>"},{"location":"vector_operations/#sf","title":"<code>sf</code>","text":"<ul> <li><code>st_buffer()</code></li> <li><code>st_centroid()</code></li> <li><code>st_convex_hull()</code></li> <li><code>st_distance()</code></li> </ul>"}]}